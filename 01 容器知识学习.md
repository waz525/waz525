#  容器知识学习链接

[《每天5分钟玩转Docker容器技术》](https://mp.weixin.qq.com/s/7o8QxGydMTUe4Q7Tz46Diw)

[《每天5分钟玩转Kubernetes》](https://mp.weixin.qq.com/s/RK6DDc8AUBklsUS7rssW2w)

#  1 容器技术


## 1.1 容器生态
``` mermaid
graph LR
A[容器生态系统]-->B[容器核心技术]
A[容器生态系统]-->C[容器平台技术]
A[容器生态系统]-->D[容器支持技术]
B-->B01[容器规范]
B-->B02[容器 runtime]
B-->B03[容器管理工具]
B-->B04[容器定义工具]
B-->B05[Registries]
B-->B06[容器 OS]
B01-->|OCI| B0101[runtime spec]
B01-->|OCI| B0102[image format spec]
B02-->|Linux| B0201[lxc]
B02-->|Docker| B0202[runc]
B02-->|CoreOS| B0203[rkt]
B03-->|lxc| B0301[lxd]
B03-->|runc| B0302[docker engine]
B03-->|rkt| B0303[rkt cli]
B04-->|Docker| B0401[docker image]
B04-->|Docker| B0402[dockerfile]
B04-->|CoreOS| B0403[ACI<br/>App Container Image]
B05-->|私有| B0501[Docker Registry]
B05-->|公共| B0502[Docker Hub <br/>https://hub.docker.com]
B05-->|公共| B0503[Quay.io <br/>https://quay.io]
B06-->B0601[CoreOS]
B06-->B0602[atomic]
B06-->B0603[ubuntu core]
C-->C01[容器编排引擎]
C-->C02[容器管理平台]
C-->C03[基于容器的PaaS]
C01-->|Docker|C0101[docker swarm]
C01-->|Google 领导|C0102[kubernetes]
C01-->C0103[mesos+marathon ]
C02-->C0201[Rancher]
C02-->C0202[ContainerShip]
C03-->C0301[Deis]
C03-->C0302[Flynn]
C03-->C0303[Dokku]
D-->D01[容器网络]
D-->D02[服务发现]
D-->D03[监管]
D-->D04[数据管理]
D-->D05[日志管理]
D-->D06[安全性]
D01-->D0101[docker network]
D01-->D0102[flannel]
D01-->D0103[weave]
D01-->D0104[calico]
D02-->D0201[etcd]
D02-->D0202[consul]
D02-->D0203[zookeeper]
D03-->|Docker原生命令|D0301[docker ps/top/stats]
D03-->|HTTP接口|D0302[docker stats API]
D03-->D0303[sysdig]
D03-->D0304[cAdvisor/Heapster]
D03-->D0305[Weave Scope]
D04-->|动态迁移|D0401[Flocker]
D05-->|Docker 原生|D0501[docker logs]
D05-->|提供路由功能|D0502[logspout]
D06-->|对镜像扫描|D0601[OpenSCAP]
```
## 1.2 Docker架构

+ Docker架构

![Docker 架构](http://mmbiz.qpic.cn/mmbiz_png/Hia4HVYXRicqGoHdCKcU42XBesbicBfOav44jzReKyPCXA4zHPLGmZZicFicf8LPiaC1fl4vkKAzl9aicbI1wyIBibxnpA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1 "Docker 架构")
+ Docker客户端 docker
  ![Docker 命令](http://mmbiz.qpic.cn/mmbiz_png/Hia4HVYXRicqGoHdCKcU42XBesbicBfOav4eU4Micd30GIRB58yQjW1gOUHxjqUIXxELET8rJOkicoCawlaIhNCau6A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1 "docker命令")

+ Docker服务端 docker.service

  默认只直接本机访问，远程访问需要修改 `/etc/systemd/system/multi-user.target.wants/docker.service` ，在 `ExecStart` 后面添加 `-H tcp://0.0.0.0`，允许来自任意 IP 的客户端连接。
  

# 2 镜像

## 2.1 最小镜像
最小镜像的dockerfile：
```dockerfile
FROM scratch
COPY hello /
CMD ["/hello"]
```
三条指令：
> 1. FROM scratch
>    此镜像是从白手起家，从 0 开始构建。
> 2. COPY hello /
>    将文件“hello”复制到镜像的根目录。
> 3. CMD ["/hello"]
>    容器启动时，执行 /hello

/hello 就是文件系统的全部内容，连最基本的 /bin，/usr, /lib, /dev 都没有。

## 2.2 base镜像

base 镜像有两层含义：

> 1. 不依赖其他镜像，从 scratch 构建。
> 2. 其他镜像可以之为基础进行扩展。

下载镜像：`docker pull centos`

查看镜像：`docker images centos`


为什么base镜像那么小？
> * Linux 操作系统由内核空间和用户空间组成。内核空间是 kernel，Linux 刚启动时会加载 bootfs 文件系统，之后 bootfs 会被卸载掉。
> * 用户空间的文件系统是 rootfs，包含我们熟悉的 /dev, /proc, /bin 等目录。
> *  base 镜像来说，底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。
> * base 镜像提供的是最小安装的 Linux 发行版。

CentOS 镜像的 Dockerfile 的内容:
```dockerfile
FROM scratch
ADD centos-7-x86_64-docker.tar.xz /
CMD ["/bin/bash"]
```
第二行 ADD 指令添加到镜像的 tar 包就是 CentOS 7 的 rootfs。在制作镜像时，这个 tar 包会自动解压到 / 目录下，生成 /dev, /porc, /bin 等目录。

说明:

> 1. base 镜像只是在用户空间与发行版一致，kernel 版本与发型版是不同的。
> 2. 容器只能使用 Host 的 kernel，并且不能修改。

## 2.3 镜像的分层结构

+ **共享资源**
  
> 新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。

+  **容器 Copy-on-Write 特性**

  > 1. **添加文件**
  >    在容器中创建文件时，新文件被添加到容器层中。
  > 2. **读取文件**
  >    在容器中读取某个文件时，Docker 会**从上往下**依次在各镜像层中查找此文件。一旦找到，打开并读入内存。
  > 3. **修改文件**
  >    在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。
  > 4. **删除文件**
  >    在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。

## 2.4 构建镜像
### 2.4.1 docker commit
docker commit 命令是创建新镜像最直观的方法，其过程包含三个步骤：
> 1. 运行容器
> 2. 修改容器
> 3. 将容器保存为新的镜像

```shell
#运行容器 -it 参数的作用是以交互模式进入容器，并打开终端
docker run -it ubuntu 
#在docker里安装 vi
apt-get install -y vim
#在新窗口中查看当前运行的容器
docker ps
#silly_goldberg 是 Docker 为我们的容器随机分配的名字。
#执行 docker commit 命令将容器保存为新镜像,命名为 ubuntu-with-vi。
docker commit silly_goldberg ubuntu-with-vi
#从新镜像启动容器
docker run -it ubuntu-with-vi 
```

Docker 不建议用户用 docker commit构建镜像。原因如下：
> 1. 这是一种手工创建镜像的方式，容易出错，效率低且可重复性弱。比如要在 debian base 镜像中也加入 vi，还得重复前面的所有步骤。
>
> 2. 更重要的：使用者并不知道镜像是如何创建出来的，里面是否有恶意程序。也就是说无法对镜像进行审计，存在安全隐患。



