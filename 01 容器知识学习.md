#  容器知识学习链接

[《每天5分钟玩转Docker容器技术》](https://mp.weixin.qq.com/s/7o8QxGydMTUe4Q7Tz46Diw)

[《每天5分钟玩转Kubernetes》](https://mp.weixin.qq.com/s/RK6DDc8AUBklsUS7rssW2w)

#  1 容器技术


## 1.1 容器生态
``` mermaid
graph LR
A[容器生态系统]-->B[容器核心技术]
A[容器生态系统]-->C[容器平台技术]
A[容器生态系统]-->D[容器支持技术]
B-->B01[容器规范]
B-->B02[容器 runtime]
B-->B03[容器管理工具]
B-->B04[容器定义工具]
B-->B05[Registries]
B-->B06[容器 OS]
B01-->|OCI| B0101[runtime spec]
B01-->|OCI| B0102[image format spec]
B02-->|Linux| B0201[lxc]
B02-->|Docker| B0202[runc]
B02-->|CoreOS| B0203[rkt]
B03-->|lxc| B0301[lxd]
B03-->|runc| B0302[docker engine]
B03-->|rkt| B0303[rkt cli]
B04-->|Docker| B0401[docker image]
B04-->|Docker| B0402[dockerfile]
B04-->|CoreOS| B0403[ACI<br/>App Container Image]
B05-->|私有| B0501[Docker Registry]
B05-->|公共| B0502[Docker Hub <br/>https://hub.docker.com]
B05-->|公共| B0503[Quay.io <br/>https://quay.io]
B06-->B0601[CoreOS]
B06-->B0602[atomic]
B06-->B0603[ubuntu core]
C-->C01[容器编排引擎]
C-->C02[容器管理平台]
C-->C03[基于容器的PaaS]
C01-->|Docker|C0101[docker swarm]
C01-->|Google 领导|C0102[kubernetes]
C01-->C0103[mesos+marathon ]
C02-->C0201[Rancher]
C02-->C0202[ContainerShip]
C03-->C0301[Deis]
C03-->C0302[Flynn]
C03-->C0303[Dokku]
D-->D01[容器网络]
D-->D02[服务发现]
D-->D03[监管]
D-->D04[数据管理]
D-->D05[日志管理]
D-->D06[安全性]
D01-->D0101[docker network]
D01-->D0102[flannel]
D01-->D0103[weave]
D01-->D0104[calico]
D02-->D0201[etcd]
D02-->D0202[consul]
D02-->D0203[zookeeper]
D03-->|Docker原生命令|D0301[docker ps/top/stats]
D03-->|HTTP接口|D0302[docker stats API]
D03-->D0303[sysdig]
D03-->D0304[cAdvisor/Heapster]
D03-->D0305[Weave Scope]
D04-->|动态迁移|D0401[Flocker]
D05-->|Docker 原生|D0501[docker logs]
D05-->|提供路由功能|D0502[logspout]
D06-->|对镜像扫描|D0601[OpenSCAP]
```
## 1.2 Docker架构

+ Docker架构

![Docker 架构](http://mmbiz.qpic.cn/mmbiz_png/Hia4HVYXRicqGoHdCKcU42XBesbicBfOav44jzReKyPCXA4zHPLGmZZicFicf8LPiaC1fl4vkKAzl9aicbI1wyIBibxnpA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1 "Docker 架构")
+ Docker客户端 docker


  ![Docker 命令](http://mmbiz.qpic.cn/mmbiz_png/Hia4HVYXRicqGoHdCKcU42XBesbicBfOav4eU4Micd30GIRB58yQjW1gOUHxjqUIXxELET8rJOkicoCawlaIhNCau6A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1 "docker命令")

+ Docker服务端 docker.service

  默认只直接本机访问，远程访问需要修改 `/etc/systemd/system/multi-user.target.wants/docker.service` ，在 `ExecStart` 后面添加 `-H tcp://0.0.0.0`，允许来自任意 IP 的客户端连接。
  

# 2 镜像

## 2.1 最小镜像
最小镜像的dockerfile：
```Dockerfile
FROM scratch
COPY hello /
CMD ["/hello"]
```
三条指令：
> 1. FROM scratch
>    此镜像是从白手起家，从 0 开始构建。
> 2. COPY hello /
>    将文件“hello”复制到镜像的根目录。
> 3. CMD ["/hello"]
>    容器启动时，执行 /hello

/hello 就是文件系统的全部内容，连最基本的 /bin，/usr, /lib, /dev 都没有。

## 2.2 base镜像

base 镜像有两层含义：

> 1. 不依赖其他镜像，从 scratch 构建。
> 2. 其他镜像可以之为基础进行扩展。

下载镜像：`docker pull centos`

查看镜像：`docker images centos`


为什么base镜像那么小？
> * Linux 操作系统由内核空间和用户空间组成。内核空间是 kernel，Linux 刚启动时会加载 bootfs 文件系统，之后 bootfs 会被卸载掉。
> * 用户空间的文件系统是 rootfs，包含我们熟悉的 /dev, /proc, /bin 等目录。
> *  base 镜像来说，底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。
> * base 镜像提供的是最小安装的 Linux 发行版。

CentOS 镜像的 Dockerfile 的内容:
```Dockerfile
FROM scratch
ADD centos-7-x86_64-docker.tar.xz /
CMD ["/bin/bash"]
```
第二行 ADD 指令添加到镜像的 tar 包就是 CentOS 7 的 rootfs。在制作镜像时，这个 tar 包会自动解压到 / 目录下，生成 /dev, /porc, /bin 等目录。

说明:

> 1. base 镜像只是在用户空间与发行版一致，kernel 版本与发型版是不同的。
> 2. 容器只能使用 Host 的 kernel，并且不能修改。

## 2.3 镜像的分层结构

+ **共享资源**
  
> 新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。

+  **容器 Copy-on-Write 特性**

  > 1. **添加文件**
  >    在容器中创建文件时，新文件被添加到容器层中。
  > 2. **读取文件**
  >    在容器中读取某个文件时，Docker 会**从上往下**依次在各镜像层中查找此文件。一旦找到，打开并读入内存。
  > 3. **修改文件**
  >    在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。
  > 4. **删除文件**
  >    在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。

## 2.4 构建镜像
### 2.4.1 docker commit
docker commit 命令是创建新镜像最直观的方法，其过程包含三个步骤：
> 1. 运行容器
> 2. 修改容器
> 3. 将容器保存为新的镜像

```shell
#运行容器 -it 参数的作用是以交互模式进入容器，并打开终端
docker run -it ubuntu 
#在docker容器里安装 vi
apt-get install -y vim
#在新窗口中查看当前运行的容器
docker ps
#silly_goldberg 是 Docker 为我们的容器随机分配的名字。
#执行 docker commit 命令将容器保存为新镜像,命名为 ubuntu-with-vi。
docker commit silly_goldberg ubuntu-with-vi
#从新镜像启动容器
docker run -it ubuntu-with-vi 
```

Docker 不建议用户用 docker commit构建镜像。原因如下：
> 1. 这是一种手工创建镜像的方式，容易出错，效率低且可重复性弱。比如要在 debian base 镜像中也加入 vi，还得重复前面的所有步骤。
>
> 2. 更重要的：使用者并不知道镜像是如何创建出来的，里面是否有恶意程序。也就是说无法对镜像进行审计，存在安全隐患。

### 2.4.2 Dockerfile

测试 Dockerfile 内容：

```Dockerfile
FROM ubuntu
RUN apt-get update && apt-get install -y vim
```

运行 docker build 命令构建镜像

```shell
root@ubuntu:~# pwd         ①  
/root  
root@ubuntu:~# ls          ②   
Dockerfile   
root@ubuntu:~# docker build -t ubuntu-with-vi-dockerfile .        ③   
Sending build context to Docker daemon 32.26 kB           ④   
Step 1 : FROM ubuntu           ⑤   
 ---> f753707788c5   
Step 2 : RUN apt-get update && apt-get install -y vim           ⑥   
 ---> Running in 9f4d4166f7e3             ⑦   
......   
Setting up vim (2:7.4.1689-3ubuntu1.1) ...   
 ---> 35ca89798937           ⑧    
Removing intermediate container 9f4d4166f7e3          ⑨   
Successfully built 35ca89798937           ⑩   
root@ubuntu:~#   
```

① 当前目录为 /root。

② Dockerfile 准备就绪。

③ 运行 docker build 命令，`-t` 将新镜像命名为 `ubuntu-with-vi-dockerfile`，命令末尾的 `.` 指明 build context 为当前目录。Docker 默认会从 build context 中查找 Dockerfile 文件，我们也可以通过 `-f` 参数指定 Dockerfile 的位置。

④ 从这步开始就是镜像真正的构建过程。 首先 Docker 将 build context 中的所有文件发送给 Docker daemon。build context 为镜像构建提供所需要的文件或目录。

Dockerfile 中的 ADD、COPY 等命令可以将 build context 中的文件添加到镜像。此例中，build context 为当前目录 `/root`，该目录下的所有文件和子目录都会被发送给 Docker daemon。

所以，使用 build context 就得小心了，不要将多余文件放到 build context，特别不要把 `/`、`/usr` 作为 build context，否则构建过程会相当缓慢甚至失败。

⑤ Step 1：执行 `FROM`，将 ubuntu 作为 base 镜像。
ubuntu 镜像 ID 为 f753707788c5。

⑥ Step 2：执行 `RUN`，安装 vim，具体步骤为 ⑦、⑧、⑨。

⑦ 启动 ID 为 9f4d4166f7e3 的临时容器，在容器中通过 apt-get 安装 vim。

⑧ 安装成功后，将容器保存为镜像，其 ID 为 35ca89798937。
**这一步底层使用的是类似 docker commit 的命令**。

⑨ 删除临时容器 9f4d4166f7e3。

⑩ 镜像构建成功。 

+ 以报销管理系统为例：

```shell
[root@localhost docker_test]# cat Dockerfile
FROM centos:7
ADD jexus-6.3.x-x64-BX20211121.tar.gz /home/
CMD /home/jexus/jwss
[root@localhost docker_test]# ls
Dockerfile  jexus-6.3.x-x64-BX20211121.tar.gz
[root@localhost docker_test]#
[root@localhost docker_test]# docker build -t fhbx .
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
STEP 1/3: FROM centos:7
STEP 2/3: ADD jexus-6.3.x-x64-BX20211121.tar.gz /home/
--> c916c9bee71
STEP 3/3: CMD /home/jexus/jwss
COMMIT fhbx
--> 0057dba583c
Successfully tagged localhost/fhbx:latest
0057dba583c6b21ecc2cbc027abbbf7820a9870ef161a2d08c6ab0d822d906e5
[root@localhost docker_test]#
[root@localhost docker_test]# docker run -d -p 8086:8085 localhost/fhbx


```

### 2.4.3 镜像缓存特性

* 1. 先构建如下镜像

```Dockerfile
FROM ubuntu
RUN apt-get update && apt-get install -y vim
```

* 2. 如果有如下Dockerfile，则会使用 1 中构建的镜像；构建第二步时，会Using cache

```Dockerfile
FROM ubuntu
RUN apt-get update && apt-get install -y vim
COPY testfile /
```

* 3. 如果有如下Dockerfile，则会不使用 1 中构建的镜像

```Dockerfile
FROM ubuntu
COPY testfile /
RUN apt-get update && apt-get install -y vim
```



## 2.5 最佳实践

### 2.5.1 Dockerfile 常用指令

**FROM**
指定 base 镜像。

**MAINTAINER**
设置镜像的作者，可以是任意字符串。

**COPY**
将文件从 build context 复制到镜像。
COPY 支持两种形式：`COPY src dest`  和 `COPY ["src", "dest"]`
注意：src 只能指定 build context 中的文件或目录。

**ADD**
与 COPY 类似，从 build context 复制文件到镜像。不同的是，如果 src 是归档文件（tar, zip, tgz, xz 等），文件会被自动解压到 dest。

**ENV**
设置环境变量，环境变量可被后面的指令使用。

**EXPOSE**
指定容器中的进程会监听某个端口，Docker 可以将该端口暴露出来。

**VOLUME**
将文件或目录声明为 volume。我们会在容器存储部分详细讨论。

**WORKDIR**
为后面的 RUN, CMD, ENTRYPOINT, ADD 或 COPY 指令设置镜像中的当前工作目录。

**RUN**
在容器中运行指定的命令。

**CMD**
容器启动时运行指定的命令。
Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效。CMD 可以被 docker run 之后的参数替换。

**ENTRYPOINT**
设置容器启动时运行的命令。
Dockerfile 中可以有多个 ENTRYPOINT 指令，但只有最后一个生效。CMD 或 docker run 之后的参数会被当做参数传递给 ENTRYPOINT。

 ***Dockerfile 支持以“#”开头的注释。***

> **RUN vs CMD vs ENTRYPOINT**
>
> > 1. 使用 RUN 指令安装应用和软件包，构建镜像。
> > 2. 如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。
> > 3. 如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。

### 2.5.2 镜像命名

镜像的名字由两部分组成：repository 和 tag

[image name] = [repository]:[tag]

+ 镜像命名: 

>  docker build -t ubuntu-with-vi

>  docker build -t ubuntu-with-vi:latest

+ tag 常用于描述镜像的版本信息: 

> docker tag myimage-v1.9.1 myimage:1
> docker tag myimage-v1.9.1 myimage:1.9
> docker tag myimage-v1.9.1 myimage:1.9.1
> docker tag myimage-v1.9.1 myimage:latest

+ 这种 tag 方案使镜像的版本很直观，用户在选择非常灵活：

> 1. myimage:1 始终指向 1 这个分支中最新的镜像。
> 2. myimage:1.9 始终指向 1.9.x 中最新的镜像。
> 3. myimage:latest 始终指向所有版本中最新的镜像。
> 4. 如果想使用特定版本，可以选择 myimage:1.9.1、myimage:1.9.2 或 myimage:2.0.0。

## 2.6 Registry 

### 2.6.1 公共 Registry

1. 在 Docker Hub 上注册一个账号： worden525

2. 在 Docker Host 上登录

   ```shell
   [root@localhost ~]# docker login -u worden525
   Password:
   Login Succeeded
   [root@localhost ~]
   ```

3. 修改镜像的 repository 使之与 Docker Hub 账号匹配，完整的镜像名：`[username]/name:tag`，使用 `docker tag` 命令重命名镜像。

   ```shell
   [root@localhost ~]# docker tag httpd worden525/httpd:1.0
   [root@localhost ~]# docker images
   REPOSITORY               TAG           IMAGE ID          CREATED             SIZE
   docker.io/httpd          latest        dabbfbe0c57b      2 weeks ago         144 MB
   worden525/httpd          1.0           dabbfbe0c57b      2 weeks ago         144 MB
   [root@localhost ~]#
   ```

4. 通过 docker push 将镜像上传到 Docker Hub

    ```shell
   [root@localhost ~]# docker push worden525/httpd:1.0
   The push refers to a repository [docker.io/worden525/httpd]
   deefaa620a71: Mounted from library/httpd
   9cff3206f9a6: Mounted from library/httpd
   15e4bf5d0804: Mounted from library/httpd
   1da636a1aa95: Mounted from library/httpd
   2edcec3590a4: Mounted from library/httpd
   1.0: digest: sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194 size: 1365
   [root@localhost ~]#
   ```

5. 登录 <https://hub.docker.com>，在Public Repository 中就可以看到上传的镜像。

6. 这个镜像可被其他 Docker host 下载使用

   ```shell
   [root@localhost ~]# docker pull worden525/httpd:1.0
   1.0: Pulling from worden525/httpd
   a2abf6c4d29d: Pull complete
   dcc4698797c8: Pull complete
   41c22baa66ec: Pull complete
   67283bbdd4a0: Pull complete
   d982c879c57e: Pull complete
   Digest: sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194
   Status: Downloaded newer image for worden525/httpd:1.0
   [root@localhost ~]#
   ```

   

### 2.6.2 本地 Registry

1. 启动 registry 容器，参数`-d` 是后台启动容器，`-p` 将容器的 5000 端口映射到 Host 的 5000 端口，`-v` 将容器 /var/lib/registry 目录映射到 Host 的 /srv/registry，用于存放镜像数据。

   ```shell
   [root@localhost ~]# docker run -d -p 5000:5000 -v /srv/registry:/var/lib/registry --name registry registry:2
   Unable to find image 'registry:2' locally
   Trying to pull repository docker.io/library/registry ...
   2: Pulling from docker.io/library/registry
   79e9f2f55bf5: Pull complete
   0d96da54f60b: Pull complete
   5b27040df4a2: Pull complete
   e2ead8259a04: Pull complete
   3790aef225b9: Pull complete
   Digest: sha256:169211e20e2f2d5d115674681eb79d21a217b296b43374b8e39f97fcf866b375
   Status: Downloaded newer image for docker.io/registry:2
   0aea79a00457d40c0a0c85151d69ce5e103faede1e70d069a57b1e5d4d7df96b
   [root@localhost ~]#
   ```

2. 通过 `docker tag` 重命名镜像，使之与 registry 匹配

   ```shell
   [root@localhost ~]#  docker tag httpd localhost:5000/worden525/httpd:v1
   [root@localhost ~]#  docker images
   REPOSITORY                       TAG         IMAGE ID        CREATED         SIZE
   docker.io/httpd                  latest      dabbfbe0c57b    2 weeks ago     144 MB
   localhost:5000/worden525/httpd   v1          dabbfbe0c57b    2 weeks ago     144 MB
   [root@localhost ~]#
   ```

3. 通过 `docker pull` 上传镜像

   ```shell
   [root@localhost ~]# docker push  localhost:5000/worden525/httpd:v1
   The push refers to a repository [localhost:5000/worden525/httpd]
   deefaa620a71: Pushed
   9cff3206f9a6: Pushed
   15e4bf5d0804: Pushed
   1da636a1aa95: Pushed
   2edcec3590a4: Pushed
   v1: digest: sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194 size: 1365
   [root@localhost ~]# cd /srv/registry/docker/registry/v2/repositories/worden525
   [root@localhost worden525]# pwd
   /srv/registry/docker/registry/v2/repositories/worden525
   [root@localhost worden525]# ls
   httpd
   [root@localhost worden525]# cd httpd/
   [root@localhost httpd]# ls
   _layers  _manifests  _uploads
   [root@localhost httpd]#
   
   ```

4. 现在已经可通过 `docker pull` 从本地 registry 下载镜像，(先使用 `docker rmi` 从删除host中的镜像)

   ```shell
   [root@localhost httpd]# docker rmi localhost:5000/worden525/httpd:v1
   Untagged: localhost:5000/worden525/httpd:v1
   Untagged: localhost:5000/worden525/httpd@sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194
   [root@localhost httpd]#
   [root@localhost httpd]# docker pull localhost:5000/worden525/httpd:v1
   Trying to pull repository localhost:5000/worden525/httpd ...
   v1: Pulling from localhost:5000/worden525/httpd
   Digest: sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194
   Status: Downloaded newer image for localhost:5000/worden525/httpd:v1
   [root@localhost httpd]#
   ```

   

# 3 容器

## 3.1 运行容器

+ **指定容器启动时执行的命令**

> 1. CMD 指令。
> 2. ENDPOINT 指令。
> 3. 在 `docker run` 命令行中指定。

+ **查看容器**
> 1. `docker ps` 或 `docker container ls`
> 2.  `docker ps -a` 或 `docker container ls -a`
>
> > > `-a` 会显示所有状态的容器，可以看到，之前的容器已经退出了，状态为`Exited`

+ #### **容器长期运行**
> 参数 `-d` 以后台方式启动容器
```shell
[root@localhost home]# docker run --name myos -d  centos:7 /bin/bash -c "while true ; do sleep 1 ;done "
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
71edc205d0115091d942c0ff4510070319998451ae0cffd8dfb5f54ff7e21c59
[root@localhost home]# docker ps
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
CONTAINER ID  IMAGE                    COMMAND               CREATED        STATUS            PORTS       NAMES
71edc205d011  quay.io/centos/centos:7  /bin/bash -c whil...  6 seconds ago  Up 5 seconds ago              myos
[root@localhost home]#
```

+ **`docker create` 创建的容器处于 Created 状态。`docker start` 将以后台方式启动容器。 `docker run` 命令实际上是 `docker create` 和 `docker start` 的组合。**

## 3.2 进入容器

+ ##### **docker attach**

> 通过 `docker attach` 可以 attach 到容器启动命令的终端，可以看到终端的信息。
>
> 通过 Ctrl+p 然后 Ctrl+q 组合键退出 attach 终端。
>
> ``` shell
> [root@localhost home]#  docker attach 8c569f58438f
> Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
> Fri Jan  7 15:54:08 UTC 2022
> Fri Jan  7 15:54:09 UTC 2022
> Fri Jan  7 15:54:10 UTC 2022
> ```

+ ##### **docker exec**

```shell
[root@localhost ~]# docker ps
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
CONTAINER ID  IMAGE                    COMMAND               CREATED         STATUS             PORTS       NAMES
8c569f58438f  quay.io/centos/centos:7  /bin/bash -c whil...  58 minutes ago  Up 58 minutes ago              myos_date
[root@localhost ~]# docker exec -it 8c569f58438f /bin/bash
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
[root@8c569f58438f /]# ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 15:00 ?        00:00:02 /bin/bash -c while true ; do sleep 1 ; date ;done
root        7114       0  4 15:59 pts/0    00:00:00 /bin/bash
root        7153       1  0 15:59 ?        00:00:00 sleep 1
root        7154    7114  0 15:59 pts/0    00:00:00 ps -ef
[root@8c569f58438f /]#
```

> ① `-it` 以交互模式打开 pseudo-TTY，执行 bash，其结果就是打开了一个 bash 终端。
>
> ② 进入到容器中，容器的 hostname 就是其 “短ID”。
>
> ③ 可以像在普通 Linux 中一样执行命令。`ps -elf` 显示了容器启动进程`while` 以及当前的 `bash` 进程。
>
> ④ 执行 `exit` 退出容器，回到 docker host。
>
> `docker exec -it <container> bash|sh` 是执行 exec 最常用的方式。

+ ##### **attach VS exec**

> 1. attach 直接进入容器 **启动命令** 的终端，不会启动新的进程。
> 2. exec 则是在容器中打开新的终端，并且可以启动新的进程。
> 3. 如果想直接在终端中查看启动命令的输出，用 attach；其他情况使用 exec。

`docker logs`用于查看日志，`-f` 的作用与 `tail -f` 类似，能够持续打印输出。

## 3.3 容器常用操作

### 3.3.1 stop/start/restart 容器

`docker start` 会保留容器的第一次启动时的所有参数。

`docker restart` 可以重启容器，其作用就是依次执行 `docker stop` 和`docker start`。

```bash
[root@localhost ~]# docker ps
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
CONTAINER ID  IMAGE                    COMMAND               CREATED     STATUS         PORTS       NAMES
8c569f58438f  quay.io/centos/centos:7  /bin/bash -c whil...  2 days ago  Up 2 days ago              myos_date
[root@localhost ~]# docker stop 8c569f58438f
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
8c569f58438f
[root@localhost ~]# docker ps
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
CONTAINER ID  IMAGE       COMMAND     CREATED     STATUS      PORTS       NAMES
[root@localhost ~]# docker start 8c569f58438f
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
8c569f58438f
[root@localhost ~]# docker ps
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
CONTAINER ID  IMAGE                    COMMAND               CREATED     STATUS            PORTS       NAMES
8c569f58438f  quay.io/centos/centos:7  /bin/bash -c whil...  2 days ago  Up 3 minutes ago              myos_date
[root@localhost ~]#
```

启动容器时设置 `--restart` 就可以达到容器能够自动重启效果。

### 3.3.2 pause/unpause 容器

有时我们只是希望暂时让容器暂停工作一段时间，比如要对容器的文件系统打个快照，或者 dcoker host 需要使用 CPU，这时可以执行 `docker pause`。

处于暂停状态的容器不会占用 CPU 资源，直到通过 `docker unpause` 恢复运行。

### 3.3.3 删除容器

使用 docker 一段时间后，host 上可能会有大量已经退出了的容器。这些容器依然会占用 host 的文件系统资源，如果确认不会再重启此类容器，可以通过 `docker rm` 删除。

`docker rm` 一次可以指定多个容器.

如果希望批量删除所有已经退出的容器，可以执行：<font color=red>  docker rm -v $(docker ps -aq -f status=exited)  </font>

*顺便说一句：`docker rm` 是删除容器，而 `docker rmi` 是删除镜像。*

## 3.4 限制容器资源

### 3.4.1 限制内存

1. `-m` 或 `--memory`：设置内存的使用限额，例如 100M, 2G。

2. `--memory-swap`：设置 **内存+swap** 的使用限额。

>
> docker run -it -m 200M --memory-swap=300M  centos:7 
>
> 其含义是允许该容器最多使用 200M 的内存和 100M 的 swap。默认情况下，上面两组参数为 -1，即对容器内存和 swap 的使用没有限制。

> 如果在启动容器时只指定 `-m` 而不指定 `--memory-swap`，那么 `--memory-swap` 默认为 `-m` 的两倍，比如：
>
> docker run -it -m 200M centos:7 
>
> 容器最多使用 200M 物理内存和 200M swap。

> docker run -it -m 200M --memory-swap=300M progrium/stress --vm 1 --vm-bytes 280M
>
> progrium/stress容器为压力测试容器，
>
> `--vm 1`：启动 1 个内存工作线程。
>
> `--vm-bytes 280M`：每个线程分配 280M 内存。

### 3.4.2 限制CPU

通过  `--cpu-shares` 设置容器使用 CPU 的权重。如果不指定，默认值为 1024。

> docker run --name container_A -it --cpu-shares 1024 progrium/stress --cpu 1
>
> docker run --name container_B -it --cpu-shares 512 progrium/stress --cpu 1

> progrium/stress容器为压力测试容器，
>
> `--cpu` progrium/stress容器的参数，用来设置工作线程的数量。

### 3.4.3 限制Block IO

+ ##### block IO 权重

通过设置 `--blkio-weight` 参数来改变容器 block IO 的优先级。设置的是相对权重值，默认为 500。

> docker run  -it --blkio-weight 300 centos:7 
>

+ ##### 限制 bps 和 iops

bps 是 byte per second，每秒读写的数据量。
iops 是 io per second，每秒 IO 的次数。

可通过以下参数控制容器的 bps 和 iops：
`--device-read-bps`，限制读某个设备的 bps。
`--device-write-bps`，限制写某个设备的 bps。
`--device-read-iops`，限制读某个设备的 iops。
`--device-write-iops`，限制写某个设备的 iops。

> docker run -it --device-write-bps /dev/sda:300MB centos:7 
>
> > time dd if=/dev/zero of=test.dd bs=1M count=800 oflag=direct
> >
> > `oflag=direct` 指定用 direct IO 方式写文件，这样 `--device-write-bps` 才能生效。

## 3.5 实现容器的底层技术

+ #### cgroup

> cgroup 全称 Control Group。Linux 操作系统通过 cgroup 可以设置进程使用 CPU、内存 和 IO 资源的限额。
>
> docker run --name container_B -it --cpu-shares 512 progrium/stress --cpu 1
>```shell
> [root@localhost ~]# docker ps  -q
> Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
> 0aaf61fea458
> [root@localhost ~]#
> [root@localhost ~]# cat /sys/fs/cgroup/cpu/machine.slice/libpod-0aaf61fea4589887b282e690c03a3bd0264b0a3579baed78d11791f4093092a3.scope/cpu.shares
> 512
> [root@localhost ~]#
> ```
> 
> 同样的，/sys/fs/cgroup/memory/docker 和 /sys/fs/cgroup/blkio/docker 中保存的是内存以及 Block IO 的 cgroup 配置。

+ #### namespace

namespace 实现了容器间资源的隔离。Linux 使用了六种 namespace，分别对应六种资源：Mount、UTS、IPC、PID、Network 和 User.

> 1. Mount namespace：让容器看上去拥有整个**文件系统**，容器有自己的 `/` 目录，可以执行 `mount` 和 `umount` 命令；
> 2. UTS namespace：让容器有自己的 **hostname**，通过 `-h` 或 `--hostname` 参数设置；
> 3. IPC namespace：让容器拥有自己的**共享内存和信号量**（semaphore）来实现进程间通信，而不会与 host 和其他容器的 IPC 混在一起。
> 4. PID namespace：容器拥有自己独立的**一套 PID**，核心进程PID为1；
> 5. Network namespace：让容器拥有自己独立的**网卡、IP、路由等资源**；
> 6. User namespace：让容器能够管理**自己的用户**，host 不能看到容器中创建的用户。

  

## 3.6 容器网络

### 3.6.1 none、host、bridge三个默认网络

Docker 安装时会自动在 host 上创建三个网络，我们可用 `docker network ls` 命令查看：
```shell
[root@localhost ~]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
b3729de88c34        bridge              bridge              local
2e434f2fc7e2        host                host                local
f0504dd10503        none                null                local
[root@localhost ~]#
```

+ ### none 网络

none 网络的容器除了 lo，没有其他任何网卡。容器创建时，可以通过 `--network=none` 指定使用 none 网络。

```shell
[root@localhost ~]# docker run -it --network=none  busybox
/ # ip l
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
/ #
[root@localhost ~]#
```

+ ### host 网络

host 网络的容器共享 Docker host 的网络栈，网络配置与 host 完全一样,通过 `--network=host` 指定。直接使用 Docker host 的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择 host 网络。

```shell
[root@localhost ~]# docker run -it --network=host  busybox
/ # ip l
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast qlen 1000
    link/ether 00:15:5d:1f:fc:0c brd ff:ff:ff:ff:ff:ff
3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue
    link/ether 02:42:25:21:d5:81 brd ff:ff:ff:ff:ff:ff
7: vethbc028b9@if6: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue master docker0
    link/ether 56:f7:91:6a:4a:40 brd ff:ff:ff:ff:ff:ff
13: veth8b87bf0@if12: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue master docker0
    link/ether 8a:3f:81:71:02:36 brd ff:ff:ff:ff:ff:ff
/ #
[root@localhost ~]#
```

+ ### bridge 网络

查看网桥：`brctl  show`

```shell
[root@localhost ~]# brctl  show
bridge name     bridge id               STP enabled     interfaces
docker0         8000.02422521d581       no
[root@localhost ~]# docker run -d  busybox /bin/sh -c "while true ; do sleep 1 ;done "
6bee24c79d9d4146769f59c5f1bc0d1be4f1dca1dec4ae3eee706ec104b00a3b
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
6bee24c79d9d        busybox             "/bin/sh -c 'while..."   6 seconds ago       Up 5 seconds                            reverent_shirley
[root@localhost ~]#
[root@localhost ~]# brctl  show
bridge name     bridge id               STP enabled     interfaces
docker0         8000.02422521d581       no              vethc368848
[root@localhost ~]#
[root@localhost ~]# docker exec -it 6bee24c79d9d /bin/sh
/ # ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
30: eth0@if31: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.2/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe11:2/64 scope link
       valid_lft forever preferred_lft forever
/ #
/ # route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         172.17.0.1      0.0.0.0         UG    0      0        0 eth0
172.17.0.0      *               255.255.0.0     U     0      0        0 eth0
/ #
[root@localhost ~]#
```

通过 `docker network inspect bridge` 看一下 bridge 网络的配置信息:

```shell
[root@localhost ~]# docker network inspect bridge
[
    {
        "Name": "bridge",
        "Id": "b3729de88c34868235f98794d2c24b4ffa18a67bfd89523b89df959a602154bd",
        "Created": "2022-01-02T13:04:57.497663647+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Containers": {
            "2c107d6d3028a7443a42e5e882bf917c099fb98546f82379f2769e9a61cf7e54": {
                "Name": "heuristic_bardeen",
                "EndpointID": "0935bffa05af4681e3808bd0b9ed8fe0f4eda363b1ec668f5928c20909ffcf1d",
                "MacAddress": "02:42:ac:11:00:02",
                "IPv4Address": "172.17.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {
            "com.docker.network.bridge.default_bridge": "true",
            "com.docker.network.bridge.enable_icc": "true",
            "com.docker.network.bridge.enable_ip_masquerade": "true",
            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",
            "com.docker.network.bridge.name": "docker0",
            "com.docker.network.driver.mtu": "1500"
        },
        "Labels": {}
    }
]
[root@localhost ~]#
```

容器创建时，docker 会自动从 172.17.0.0/16 中分配一个 IP，这里 16 位的掩码保证有足够多的 IP 可以供容器使用。

### 3.6.2 自定义容器网络

Docker 提供三种 user-defined 网络驱动：bridge, overlay 和 macvlan。overlay 和 macvlan 用于创建跨主机的网络，此处演示bridge。

+ 创建并使用新网络

```shell
[root@localhost ~]# docker network create --driver bridge my_net
e7c6e0b50213157e2514a3c0616be0ffcc3a0f0828c760601a225a8286b966fe
[root@localhost ~]# 
[root@localhost ~]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
b3729de88c34        bridge              bridge              local
2e434f2fc7e2        host                host                local
e7c6e0b50213        my_net              bridge              local
f0504dd10503        none                null                local
[root@localhost ~]#
[root@localhost ~]# brctl  show
bridge name     bridge id               STP enabled     interfaces
br-e7c6e0b50213         8000.0242c5af78fa       no
docker0         8000.02422521d581       no
[root@localhost ~]#
[root@localhost ~]# docker run -d  --network=my_net busybox /bin/sh -c "while true ; do sleep 1 ;done "
37a6ddc46be1370253313be449725d063555169ee0ef802faed801363e3e4074
[root@localhost ~]# docker exec -it 37a6ddc46be1 /bin/sh
/ # ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
33: eth0@if34: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.2/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe12:2/64 scope link
       valid_lft forever preferred_lft forever
/ # route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         172.18.0.1      0.0.0.0         UG    0      0        0 eth0
172.18.0.0      *               255.255.0.0     U     0      0        0 eth0
/ #
[root@localhost ~]#

```

+ 查看新网络配置，并设置网络

```shell
[root@localhost ~]# docker network inspect  my_net
[
    {
        "Name": "my_net",
        "Id": "e7c6e0b50213157e2514a3c0616be0ffcc3a0f0828c760601a225a8286b966fe",
        "Created": "2022-01-17T00:45:38.739641533+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Containers": {
            "37a6ddc46be1370253313be449725d063555169ee0ef802faed801363e3e4074": {
                "Name": "sad_poincare",
                "EndpointID": "37a56591c672b6869158ddbd6655a7cfd061350ab961be677ad817a9afc96e65",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]
[root@localhost ~]#
[root@localhost ~]# docker network create --driver bridge  --subnet 172.22.1.0/24 --gateway 172.22.1.1 my_net2
e3947fe7f93b05ee237c3b69638d92532a9cbb6fedb0555b7c0b48dc7f62e167
[root@localhost ~]# docker network inspect  my_net2
[
    {
        "Name": "my_net2",
        "Id": "e3947fe7f93b05ee237c3b69638d92532a9cbb6fedb0555b7c0b48dc7f62e167",
        "Created": "2022-01-17T00:55:40.521742955+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.22.1.0/24",
                    "Gateway": "172.22.1.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]
[root@localhost ~]#

```

+ 使用`--ip`指定窗口的IP

```shell
[root@localhost ~]# docker run -it --network=my_net2 --ip 172.22.1.34 busybox
/ # ip  a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
38: eth0@if39: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue
    link/ether 02:42:ac:16:01:22 brd ff:ff:ff:ff:ff:ff
    inet 172.22.1.34/24 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe16:122/64 scope link
       valid_lft forever preferred_lft forever
/ #
[root@localhost ~]#
```

注：**只有使用 `--subnet` 创建的网络才能指定静态 IP**。

### 3.6.3 容器之间的连通性

+ 1. 同一网络中的容器、网关之间都是可以通信的；
+ 2. 不同网络中的容器是不可以通信的；

```shell
[root@localhost ~]# ip r
default via 192.167.1.1 dev eth0 proto static metric 100
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1
172.18.0.0/16 dev br-e7c6e0b50213 proto kernel scope link src 172.18.0.1
172.22.1.0/24 dev br-e3947fe7f93b proto kernel scope link src 172.22.1.1
192.167.1.0/24 dev eth0 proto kernel scope link src 192.167.1.241 metric 100
[root@localhost ~]#
[root@localhost ~]# sysctl -a 2>/dev/zero |  grep net.ipv4.ip_forward
net.ipv4.ip_forward = 1
net.ipv4.ip_forward_use_pmtu = 0
[root@localhost ~]# #iptables DROP 掉了网桥 docker0 与 br-e3947fe7f93b / br-e7c6e0b50213 之间双向的流量。
[root@localhost ~]# iptables-save |grep DOCKER-ISOLATION   
:DOCKER-ISOLATION - [0:0]
-A FORWARD -j DOCKER-ISOLATION
-A DOCKER-ISOLATION -i br-e7c6e0b50213 -o br-e3947fe7f93b -j DROP
-A DOCKER-ISOLATION -i br-e3947fe7f93b -o br-e7c6e0b50213 -j DROP
-A DOCKER-ISOLATION -i docker0 -o br-e3947fe7f93b -j DROP
-A DOCKER-ISOLATION -i br-e3947fe7f93b -o docker0 -j DROP
-A DOCKER-ISOLATION -i docker0 -o br-e7c6e0b50213 -j DROP
-A DOCKER-ISOLATION -i br-e7c6e0b50213 -o docker0 -j DROP
-A DOCKER-ISOLATION -j RETURN
[root@localhost ~]#

```

+ 3. 不同网络中的容器，通过`docker network connect` 命令增加网卡，使之同网络。

```shell
[root@localhost ~]# docker run -d --name busybox_1 --network=my_net busybox /bin/sh -c "while true ; do sleep 1 ;done "
19516570d51e01767ad9371f63d7194add430191cf09625f5091fc5e83f46719
[root@localhost ~]# docker run -d --name busybox_2 --network=my_net2 --ip 172.22.1.34  busybox /bin/sh -c "while true ; do sleep 1 ;done "
2cfb80d5864ae67565ef57c2de68544d7eb7309f62c3c419c6fe69d7d701a511
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES
2cfb80d5864a        busybox             "/bin/sh -c 'while..."   36 seconds ago       Up 35 seconds                           busybox_2
19516570d51e        busybox             "/bin/sh -c 'while..."   About a minute ago   Up About a minute                       busybox_1
[root@localhost ~]#
[root@localhost ~]#
[root@localhost ~]# docker exec -it busybox_1 /bin/sh
/ # ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
44: eth0@if45: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.2/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe12:2/64 scope link
       valid_lft forever preferred_lft forever
/ # ping 172.22.1.34
PING 172.22.1.34 (172.22.1.34): 56 data bytes
^C
--- 172.22.1.34 ping statistics ---
2 packets transmitted, 0 packets received, 100% packet loss
/ #
[root@localhost ~]#
[root@localhost ~]# docker network connect my_net2 busybox_1
[root@localhost ~]#
[root@localhost ~]# docker exec -it busybox_1 /bin/sh
/ # ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
44: eth0@if45: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.2/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe12:2/64 scope link
       valid_lft forever preferred_lft forever
48: eth1@if49: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue
    link/ether 02:42:ac:16:01:02 brd ff:ff:ff:ff:ff:ff
    inet 172.22.1.2/24 scope global eth1
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe16:102/64 scope link
       valid_lft forever preferred_lft forever
/ # ping 172.22.1.34
PING 172.22.1.34 (172.22.1.34): 56 data bytes
64 bytes from 172.22.1.34: seq=0 ttl=64 time=0.144 ms
64 bytes from 172.22.1.34: seq=1 ttl=64 time=0.105 ms
64 bytes from 172.22.1.34: seq=2 ttl=64 time=0.110 ms
^C
--- 172.22.1.34 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.105/0.119/0.144 ms
/ #
[root@localhost ~]#


```

+ 4. 通过joined 容器进行互通访问 

```shell
[root@localhost ~]# docker run -d -it --name=web1 httpd
4da641e77405b66371652b458e044e29614d6158f4905753b1cc8b67613f8961
[root@localhost ~]# docker run -it --network=container:web1 busybox
/ # wget http://127.0.0.1/
Connecting to 127.0.0.1 (127.0.0.1:80)
saving to 'index.html'
index.html           100% |*****************************************************************************************|    45  0:00:00 ETA
'index.html' saved
/ #
[root@localhost ~]#
```

busybox 和 web1 的网卡 mac 地址与 IP 完全一样，它们共享了相同的网络栈。busybox 可以直接用 127.0.0.1 访问 web1 的 http 服务。joined 容器非常适合以下场景：

> 1. 不同容器中的程序希望通过 loopback 高效快速地通信，比如 web server 与 app server。
> 2. 希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。





# 附录1：docker命令检索

images   显示镜像列表

history  显示镜像构建历史

commit   从容器创建新镜像

build   从 Dockerfile 构建镜像

tag    给镜像打 tag

pull    从 registry 下载镜像

push    将 镜像 上传到 registry

rmi    删除 Docker host 中的镜像

search   搜索 Docker Hub 中的镜像



