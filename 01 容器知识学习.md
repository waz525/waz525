#  容器知识学习链接

[《每天5分钟玩转Docker容器技术》](https://mp.weixin.qq.com/s/7o8QxGydMTUe4Q7Tz46Diw)

[《每天5分钟玩转Kubernetes》](https://mp.weixin.qq.com/s/RK6DDc8AUBklsUS7rssW2w)

#  1 容器技术


## 1.1 容器生态
``` mermaid
graph LR
A[容器生态系统]-->B[容器核心技术]
A[容器生态系统]-->C[容器平台技术]
A[容器生态系统]-->D[容器支持技术]
B-->B01[容器规范]
B-->B02[容器 runtime]
B-->B03[容器管理工具]
B-->B04[容器定义工具]
B-->B05[Registries]
B-->B06[容器 OS]
B01-->|OCI| B0101[runtime spec]
B01-->|OCI| B0102[image format spec]
B02-->|Linux| B0201[lxc]
B02-->|Docker| B0202[runc]
B02-->|CoreOS| B0203[rkt]
B03-->|lxc| B0301[lxd]
B03-->|runc| B0302[docker engine]
B03-->|rkt| B0303[rkt cli]
B04-->|Docker| B0401[docker image]
B04-->|Docker| B0402[dockerfile]
B04-->|CoreOS| B0403[ACI<br/>App Container Image]
B05-->|私有| B0501[Docker Registry]
B05-->|公共| B0502[Docker Hub <br/>https://hub.docker.com]
B05-->|公共| B0503[Quay.io <br/>https://quay.io]
B06-->B0601[CoreOS]
B06-->B0602[atomic]
B06-->B0603[ubuntu core]
C-->C01[容器编排引擎]
C-->C02[容器管理平台]
C-->C03[基于容器的PaaS]
C01-->|Docker|C0101[docker swarm]
C01-->|Google 领导|C0102[kubernetes]
C01-->C0103[mesos+marathon ]
C02-->C0201[Rancher]
C02-->C0202[ContainerShip]
C03-->C0301[Deis]
C03-->C0302[Flynn]
C03-->C0303[Dokku]
D-->D01[容器网络]
D-->D02[服务发现]
D-->D03[监管]
D-->D04[数据管理]
D-->D05[日志管理]
D-->D06[安全性]
D01-->D0101[docker network]
D01-->D0102[flannel]
D01-->D0103[weave]
D01-->D0104[calico]
D02-->D0201[etcd]
D02-->D0202[consul]
D02-->D0203[zookeeper]
D03-->|Docker原生命令|D0301[docker ps/top/stats]
D03-->|HTTP接口|D0302[docker stats API]
D03-->D0303[sysdig]
D03-->D0304[cAdvisor/Heapster]
D03-->D0305[Weave Scope]
D04-->|动态迁移|D0401[Flocker]
D05-->|Docker 原生|D0501[docker logs]
D05-->|提供路由功能|D0502[logspout]
D06-->|对镜像扫描|D0601[OpenSCAP]
```
## 1.2 Docker架构

+ Docker架构

![Docker 架构](http://mmbiz.qpic.cn/mmbiz_png/Hia4HVYXRicqGoHdCKcU42XBesbicBfOav44jzReKyPCXA4zHPLGmZZicFicf8LPiaC1fl4vkKAzl9aicbI1wyIBibxnpA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1 "Docker 架构")
+ Docker客户端 docker


  ![Docker 命令](http://mmbiz.qpic.cn/mmbiz_png/Hia4HVYXRicqGoHdCKcU42XBesbicBfOav4eU4Micd30GIRB58yQjW1gOUHxjqUIXxELET8rJOkicoCawlaIhNCau6A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1 "docker命令")

+ Docker服务端 docker.service

  默认只直接本机访问，远程访问需要修改 `/etc/systemd/system/multi-user.target.wants/docker.service` ，在 `ExecStart` 后面添加 `-H tcp://0.0.0.0`，允许来自任意 IP 的客户端连接。
  

# 2 镜像

## 2.1 最小镜像
最小镜像的dockerfile：
```Dockerfile
FROM scratch
COPY hello /
CMD ["/hello"]
```
三条指令：
> 1. FROM scratch
>    此镜像是从白手起家，从 0 开始构建。
> 2. COPY hello /
>    将文件“hello”复制到镜像的根目录。
> 3. CMD ["/hello"]
>    容器启动时，执行 /hello

/hello 就是文件系统的全部内容，连最基本的 /bin，/usr, /lib, /dev 都没有。

## 2.2 base镜像

base 镜像有两层含义：

> 1. 不依赖其他镜像，从 scratch 构建。
> 2. 其他镜像可以之为基础进行扩展。

下载镜像：`docker pull centos`

查看镜像：`docker images centos`


为什么base镜像那么小？
> * Linux 操作系统由内核空间和用户空间组成。内核空间是 kernel，Linux 刚启动时会加载 bootfs 文件系统，之后 bootfs 会被卸载掉。
> * 用户空间的文件系统是 rootfs，包含我们熟悉的 /dev, /proc, /bin 等目录。
> *  base 镜像来说，底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。
> * base 镜像提供的是最小安装的 Linux 发行版。

CentOS 镜像的 Dockerfile 的内容:
```Dockerfile
FROM scratch
ADD centos-7-x86_64-docker.tar.xz /
CMD ["/bin/bash"]
```
第二行 ADD 指令添加到镜像的 tar 包就是 CentOS 7 的 rootfs。在制作镜像时，这个 tar 包会自动解压到 / 目录下，生成 /dev, /porc, /bin 等目录。

说明:

> 1. base 镜像只是在用户空间与发行版一致，kernel 版本与发型版是不同的。
> 2. 容器只能使用 Host 的 kernel，并且不能修改。

## 2.3 镜像的分层结构

+ **共享资源**
  
> 新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。

+  **容器 Copy-on-Write 特性**

  > 1. **添加文件**
  >    在容器中创建文件时，新文件被添加到容器层中。
  > 2. **读取文件**
  >    在容器中读取某个文件时，Docker 会**从上往下**依次在各镜像层中查找此文件。一旦找到，打开并读入内存。
  > 3. **修改文件**
  >    在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。
  > 4. **删除文件**
  >    在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。

## 2.4 构建镜像
### 2.4.1 docker commit
docker commit 命令是创建新镜像最直观的方法，其过程包含三个步骤：
> 1. 运行容器
> 2. 修改容器
> 3. 将容器保存为新的镜像

```shell
#运行容器 -it 参数的作用是以交互模式进入容器，并打开终端
docker run -it ubuntu 
#在docker容器里安装 vi
apt-get install -y vim
#在新窗口中查看当前运行的容器
docker ps
#silly_goldberg 是 Docker 为我们的容器随机分配的名字。
#执行 docker commit 命令将容器保存为新镜像,命名为 ubuntu-with-vi。
docker commit silly_goldberg ubuntu-with-vi
#从新镜像启动容器
docker run -it ubuntu-with-vi 
```

Docker 不建议用户用 docker commit构建镜像。原因如下：
> 1. 这是一种手工创建镜像的方式，容易出错，效率低且可重复性弱。比如要在 debian base 镜像中也加入 vi，还得重复前面的所有步骤。
>
> 2. 更重要的：使用者并不知道镜像是如何创建出来的，里面是否有恶意程序。也就是说无法对镜像进行审计，存在安全隐患。

### 2.4.2 Dockerfile

测试 Dockerfile 内容：

```Dockerfile
FROM ubuntu
RUN apt-get update && apt-get install -y vim
```

运行 docker build 命令构建镜像

```shell
root@ubuntu:~# pwd         ①  
/root  
root@ubuntu:~# ls          ②   
Dockerfile   
root@ubuntu:~# docker build -t ubuntu-with-vi-dockerfile .        ③   
Sending build context to Docker daemon 32.26 kB           ④   
Step 1 : FROM ubuntu           ⑤   
 ---> f753707788c5   
Step 2 : RUN apt-get update && apt-get install -y vim           ⑥   
 ---> Running in 9f4d4166f7e3             ⑦   
......   
Setting up vim (2:7.4.1689-3ubuntu1.1) ...   
 ---> 35ca89798937           ⑧    
Removing intermediate container 9f4d4166f7e3          ⑨   
Successfully built 35ca89798937           ⑩   
root@ubuntu:~#   
```

① 当前目录为 /root。

② Dockerfile 准备就绪。

③ 运行 docker build 命令，`-t` 将新镜像命名为 `ubuntu-with-vi-dockerfile`，命令末尾的 `.` 指明 build context 为当前目录。Docker 默认会从 build context 中查找 Dockerfile 文件，我们也可以通过 `-f` 参数指定 Dockerfile 的位置。

④ 从这步开始就是镜像真正的构建过程。 首先 Docker 将 build context 中的所有文件发送给 Docker daemon。build context 为镜像构建提供所需要的文件或目录。

Dockerfile 中的 ADD、COPY 等命令可以将 build context 中的文件添加到镜像。此例中，build context 为当前目录 `/root`，该目录下的所有文件和子目录都会被发送给 Docker daemon。

所以，使用 build context 就得小心了，不要将多余文件放到 build context，特别不要把 `/`、`/usr` 作为 build context，否则构建过程会相当缓慢甚至失败。

⑤ Step 1：执行 `FROM`，将 ubuntu 作为 base 镜像。
ubuntu 镜像 ID 为 f753707788c5。

⑥ Step 2：执行 `RUN`，安装 vim，具体步骤为 ⑦、⑧、⑨。

⑦ 启动 ID 为 9f4d4166f7e3 的临时容器，在容器中通过 apt-get 安装 vim。

⑧ 安装成功后，将容器保存为镜像，其 ID 为 35ca89798937。
**这一步底层使用的是类似 docker commit 的命令**。

⑨ 删除临时容器 9f4d4166f7e3。

⑩ 镜像构建成功。 

+ 以报销管理系统为例：

```shell
[root@localhost docker_test]# cat Dockerfile
FROM centos:7
ADD jexus-6.3.x-x64-BX20211121.tar.gz /home/
CMD /home/jexus/jwss
[root@localhost docker_test]# ls
Dockerfile  jexus-6.3.x-x64-BX20211121.tar.gz
[root@localhost docker_test]#
[root@localhost docker_test]# docker build -t fhbx .
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
STEP 1/3: FROM centos:7
STEP 2/3: ADD jexus-6.3.x-x64-BX20211121.tar.gz /home/
--> c916c9bee71
STEP 3/3: CMD /home/jexus/jwss
COMMIT fhbx
--> 0057dba583c
Successfully tagged localhost/fhbx:latest
0057dba583c6b21ecc2cbc027abbbf7820a9870ef161a2d08c6ab0d822d906e5
[root@localhost docker_test]#
[root@localhost docker_test]# docker run -d -p 8086:8085 localhost/fhbx


```

### 2.4.3 镜像缓存特性

* 1. 先构建如下镜像

```Dockerfile
FROM ubuntu
RUN apt-get update && apt-get install -y vim
```

* 2. 如果有如下Dockerfile，则会使用 1 中构建的镜像；构建第二步时，会Using cache

```Dockerfile
FROM ubuntu
RUN apt-get update && apt-get install -y vim
COPY testfile /
```

* 3. 如果有如下Dockerfile，则会不使用 1 中构建的镜像

```Dockerfile
FROM ubuntu
COPY testfile /
RUN apt-get update && apt-get install -y vim
```



## 2.5 最佳实践

### 2.5.1 Dockerfile 常用指令

**FROM**
指定 base 镜像。

**MAINTAINER**
设置镜像的作者，可以是任意字符串。

**COPY**
将文件从 build context 复制到镜像。
COPY 支持两种形式：`COPY src dest`  和 `COPY ["src", "dest"]`
注意：src 只能指定 build context 中的文件或目录。

**ADD**
与 COPY 类似，从 build context 复制文件到镜像。不同的是，如果 src 是归档文件（tar, zip, tgz, xz 等），文件会被自动解压到 dest。

**ENV**
设置环境变量，环境变量可被后面的指令使用。

**EXPOSE**
指定容器中的进程会监听某个端口，Docker 可以将该端口暴露出来。

**VOLUME**
将文件或目录声明为 volume。我们会在容器存储部分详细讨论。

**WORKDIR**
为后面的 RUN, CMD, ENTRYPOINT, ADD 或 COPY 指令设置镜像中的当前工作目录。

**RUN**
在容器中运行指定的命令。

**CMD**
容器启动时运行指定的命令。
Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效。CMD 可以被 docker run 之后的参数替换。

**ENTRYPOINT**
设置容器启动时运行的命令。
Dockerfile 中可以有多个 ENTRYPOINT 指令，但只有最后一个生效。CMD 或 docker run 之后的参数会被当做参数传递给 ENTRYPOINT。

 ***Dockerfile 支持以“#”开头的注释。***

> **RUN vs CMD vs ENTRYPOINT**
>
> > 1. 使用 RUN 指令安装应用和软件包，构建镜像。
> > 2. 如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。
> > 3. 如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。

### 2.5.2 镜像命名

镜像的名字由两部分组成：repository 和 tag

[image name] = [repository]:[tag]

+ 镜像命名: 

>  docker build -t ubuntu-with-vi

>  docker build -t ubuntu-with-vi:latest

+ tag 常用于描述镜像的版本信息: 

> docker tag myimage-v1.9.1 myimage:1
> docker tag myimage-v1.9.1 myimage:1.9
> docker tag myimage-v1.9.1 myimage:1.9.1
> docker tag myimage-v1.9.1 myimage:latest

+ 这种 tag 方案使镜像的版本很直观，用户在选择非常灵活：

> 1. myimage:1 始终指向 1 这个分支中最新的镜像。
> 2. myimage:1.9 始终指向 1.9.x 中最新的镜像。
> 3. myimage:latest 始终指向所有版本中最新的镜像。
> 4. 如果想使用特定版本，可以选择 myimage:1.9.1、myimage:1.9.2 或 myimage:2.0.0。

## 2.6 Registry 

### 2.6.1 公共 Registry

1. 在 Docker Hub 上注册一个账号： worden525

2. 在 Docker Host 上登录

   ```shell
   [root@localhost ~]# docker login -u worden525
   Password:
   Login Succeeded
   [root@localhost ~]
   ```

3. 修改镜像的 repository 使之与 Docker Hub 账号匹配，完整的镜像名：`[username]/name:tag`，使用 `docker tag` 命令重命名镜像。

   ```shell
   [root@localhost ~]# docker tag httpd worden525/httpd:1.0
   [root@localhost ~]# docker images
   REPOSITORY               TAG           IMAGE ID          CREATED             SIZE
   docker.io/httpd          latest        dabbfbe0c57b      2 weeks ago         144 MB
   worden525/httpd          1.0           dabbfbe0c57b      2 weeks ago         144 MB
   [root@localhost ~]#
   ```

4. 通过 docker push 将镜像上传到 Docker Hub

    ```shell
   [root@localhost ~]# docker push worden525/httpd:1.0
   The push refers to a repository [docker.io/worden525/httpd]
   deefaa620a71: Mounted from library/httpd
   9cff3206f9a6: Mounted from library/httpd
   15e4bf5d0804: Mounted from library/httpd
   1da636a1aa95: Mounted from library/httpd
   2edcec3590a4: Mounted from library/httpd
   1.0: digest: sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194 size: 1365
   [root@localhost ~]#
   ```

5. 登录 <https://hub.docker.com>，在Public Repository 中就可以看到上传的镜像。

6. 这个镜像可被其他 Docker host 下载使用

   ```shell
   [root@localhost ~]# docker pull worden525/httpd:1.0
   1.0: Pulling from worden525/httpd
   a2abf6c4d29d: Pull complete
   dcc4698797c8: Pull complete
   41c22baa66ec: Pull complete
   67283bbdd4a0: Pull complete
   d982c879c57e: Pull complete
   Digest: sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194
   Status: Downloaded newer image for worden525/httpd:1.0
   [root@localhost ~]#
   ```

   

### 2.6.2 本地 Registry

1. 启动 registry 容器，参数`-d` 是后台启动容器，`-p` 将容器的 5000 端口映射到 Host 的 5000 端口，`-v` 将容器 /var/lib/registry 目录映射到 Host 的 /srv/registry，用于存放镜像数据。

   ```shell
   [root@localhost ~]# docker run -d -p 5000:5000 -v /srv/registry:/var/lib/registry --name registry registry:2
   Unable to find image 'registry:2' locally
   Trying to pull repository docker.io/library/registry ...
   2: Pulling from docker.io/library/registry
   79e9f2f55bf5: Pull complete
   0d96da54f60b: Pull complete
   5b27040df4a2: Pull complete
   e2ead8259a04: Pull complete
   3790aef225b9: Pull complete
   Digest: sha256:169211e20e2f2d5d115674681eb79d21a217b296b43374b8e39f97fcf866b375
   Status: Downloaded newer image for docker.io/registry:2
   0aea79a00457d40c0a0c85151d69ce5e103faede1e70d069a57b1e5d4d7df96b
   [root@localhost ~]#
   ```

2. 通过 `docker tag` 重命名镜像，使之与 registry 匹配

   ```shell
   [root@localhost ~]#  docker tag httpd localhost:5000/worden525/httpd:v1
   [root@localhost ~]#  docker images
   REPOSITORY                       TAG         IMAGE ID        CREATED         SIZE
   docker.io/httpd                  latest      dabbfbe0c57b    2 weeks ago     144 MB
   localhost:5000/worden525/httpd   v1          dabbfbe0c57b    2 weeks ago     144 MB
   [root@localhost ~]#
   ```

3. 通过 `docker pull` 上传镜像

   ```shell
   [root@localhost ~]# docker push  localhost:5000/worden525/httpd:v1
   The push refers to a repository [localhost:5000/worden525/httpd]
   deefaa620a71: Pushed
   9cff3206f9a6: Pushed
   15e4bf5d0804: Pushed
   1da636a1aa95: Pushed
   2edcec3590a4: Pushed
   v1: digest: sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194 size: 1365
   [root@localhost ~]# cd /srv/registry/docker/registry/v2/repositories/worden525
   [root@localhost worden525]# pwd
   /srv/registry/docker/registry/v2/repositories/worden525
   [root@localhost worden525]# ls
   httpd
   [root@localhost worden525]# cd httpd/
   [root@localhost httpd]# ls
   _layers  _manifests  _uploads
   [root@localhost httpd]#
   
   ```

4. 现在已经可通过 `docker pull` 从本地 registry 下载镜像，(先使用 `docker rmi` 从删除host中的镜像)

   ```shell
   [root@localhost httpd]# docker rmi localhost:5000/worden525/httpd:v1
   Untagged: localhost:5000/worden525/httpd:v1
   Untagged: localhost:5000/worden525/httpd@sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194
   [root@localhost httpd]#
   [root@localhost httpd]# docker pull localhost:5000/worden525/httpd:v1
   Trying to pull repository localhost:5000/worden525/httpd ...
   v1: Pulling from localhost:5000/worden525/httpd
   Digest: sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194
   Status: Downloaded newer image for localhost:5000/worden525/httpd:v1
   [root@localhost httpd]#
   ```

   

# 3 容器

## 3.1 运行容器

+ **指定容器启动时执行的命令**

> 1. CMD 指令。
> 2. ENDPOINT 指令。
> 3. 在 `docker run` 命令行中指定。

+ **查看容器**
> 1. `docker ps` 或 `docker container ls`
> 2.  `docker ps -a` 或 `docker container ls -a`
>
> > > `-a` 会显示所有状态的容器，可以看到，之前的容器已经退出了，状态为`Exited`

+ #### **容器长期运行**
> 参数 `-d` 以后台方式启动容器
```shell
[root@localhost home]# docker run --name myos -d  centos:7 /bin/bash -c "while true ; do sleep 1 ;done "
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
71edc205d0115091d942c0ff4510070319998451ae0cffd8dfb5f54ff7e21c59
[root@localhost home]# docker ps
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
CONTAINER ID  IMAGE                    COMMAND               CREATED        STATUS            PORTS       NAMES
71edc205d011  quay.io/centos/centos:7  /bin/bash -c whil...  6 seconds ago  Up 5 seconds ago              myos
[root@localhost home]#
```

## 3.2 进入容器

+ ##### **docker attach**

> 通过 `docker attach` 可以 attach 到容器启动命令的终端，可以看到终端的信息。
>
> 通过 Ctrl+p 然后 Ctrl+q 组合键退出 attach 终端。
>
> ``` shell
> [root@localhost home]#  docker attach 8c569f58438f
> Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
> Fri Jan  7 15:54:08 UTC 2022
> Fri Jan  7 15:54:09 UTC 2022
> Fri Jan  7 15:54:10 UTC 2022
> ```

+ ##### **docker exec**

```shell
[root@localhost ~]# docker ps
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
CONTAINER ID  IMAGE                    COMMAND               CREATED         STATUS             PORTS       NAMES
8c569f58438f  quay.io/centos/centos:7  /bin/bash -c whil...  58 minutes ago  Up 58 minutes ago              myos_date
[root@localhost ~]# docker exec -it 8c569f58438f /bin/bash
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
[root@8c569f58438f /]# ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 15:00 ?        00:00:02 /bin/bash -c while true ; do sleep 1 ; date ;done
root        7114       0  4 15:59 pts/0    00:00:00 /bin/bash
root        7153       1  0 15:59 ?        00:00:00 sleep 1
root        7154    7114  0 15:59 pts/0    00:00:00 ps -ef
[root@8c569f58438f /]#
```

> ① `-it` 以交互模式打开 pseudo-TTY，执行 bash，其结果就是打开了一个 bash 终端。
>
> ② 进入到容器中，容器的 hostname 就是其 “短ID”。
>
> ③ 可以像在普通 Linux 中一样执行命令。`ps -elf` 显示了容器启动进程`while` 以及当前的 `bash` 进程。
>
> ④ 执行 `exit` 退出容器，回到 docker host。
>
> `docker exec -it <container> bash|sh` 是执行 exec 最常用的方式。

+ ##### **attach VS exec**

> 1. attach 直接进入容器 **启动命令** 的终端，不会启动新的进程。
> 2. exec 则是在容器中打开新的终端，并且可以启动新的进程。
> 3. 如果想直接在终端中查看启动命令的输出，用 attach；其他情况使用 exec。

`docker logs`用于查看日志，`-f` 的作用与 `tail -f` 类似，能够持续打印输出。

## 3.3 




# 附录1：docker命令检索

images   显示镜像列表

history  显示镜像构建历史

commit   从容器创建新镜像

build   从 Dockerfile 构建镜像

tag    给镜像打 tag

pull    从 registry 下载镜像

push    将 镜像 上传到 registry

rmi    删除 Docker host 中的镜像

search   搜索 Docker Hub 中的镜像



