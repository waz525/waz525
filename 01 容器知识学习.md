#  容器知识学习链接

[《每天5分钟玩转Docker容器技术》](https://mp.weixin.qq.com/s/7o8QxGydMTUe4Q7Tz46Diw)

[《每天5分钟玩转Kubernetes》](https://mp.weixin.qq.com/s/RK6DDc8AUBklsUS7rssW2w)

#  1 容器技术

## 1.1 容器生态

见附录99

## 1.2 Docker架构

+ Docker架构

![Docker 架构](http://mmbiz.qpic.cn/mmbiz_png/Hia4HVYXRicqGoHdCKcU42XBesbicBfOav44jzReKyPCXA4zHPLGmZZicFicf8LPiaC1fl4vkKAzl9aicbI1wyIBibxnpA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1 "Docker 架构")
+ Docker客户端 docker


  ![Docker 命令](http://mmbiz.qpic.cn/mmbiz_png/Hia4HVYXRicqGoHdCKcU42XBesbicBfOav4eU4Micd30GIRB58yQjW1gOUHxjqUIXxELET8rJOkicoCawlaIhNCau6A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1 "docker命令")

+ Docker服务端 docker.service

  默认只直接本机访问，远程访问需要修改 `/etc/systemd/system/multi-user.target.wants/docker.service` ，在 `ExecStart` 后面添加 `-H tcp://0.0.0.0`，允许来自任意 IP 的客户端连接。
  

# 2 镜像

## 2.1 最小镜像
最小镜像的dockerfile：
```Dockerfile
FROM scratch
COPY hello /
CMD ["/hello"]
```
三条指令：
> 1. FROM scratch
>    此镜像是从白手起家，从 0 开始构建。
> 2. COPY hello /
>    将文件“hello”复制到镜像的根目录。
> 3. CMD ["/hello"]
>    容器启动时，执行 /hello

/hello 就是文件系统的全部内容，连最基本的 /bin，/usr, /lib, /dev 都没有。

## 2.2 base镜像

base 镜像有两层含义：

> 1. 不依赖其他镜像，从 scratch 构建。
> 2. 其他镜像可以之为基础进行扩展。

下载镜像：`docker pull centos`

查看镜像：`docker images centos`


为什么base镜像那么小？
> * Linux 操作系统由内核空间和用户空间组成。内核空间是 kernel，Linux 刚启动时会加载 bootfs 文件系统，之后 bootfs 会被卸载掉。
> * 用户空间的文件系统是 rootfs，包含我们熟悉的 /dev, /proc, /bin 等目录。
> *  base 镜像来说，底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。
> * base 镜像提供的是最小安装的 Linux 发行版。

CentOS 镜像的 Dockerfile 的内容:
```Dockerfile
FROM scratch
ADD centos-7-x86_64-docker.tar.xz /
CMD ["/bin/bash"]
```
第二行 ADD 指令添加到镜像的 tar 包就是 CentOS 7 的 rootfs。在制作镜像时，这个 tar 包会自动解压到 / 目录下，生成 /dev, /porc, /bin 等目录。

说明:

> 1. base 镜像只是在用户空间与发行版一致，kernel 版本与发型版是不同的。
> 2. 容器只能使用 Host 的 kernel，并且不能修改。

## 2.3 镜像的分层结构

+ **共享资源**
  
> 新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。

+  **容器 Copy-on-Write 特性**

  > 1. **添加文件**
  >    在容器中创建文件时，新文件被添加到容器层中。
  > 2. **读取文件**
  >    在容器中读取某个文件时，Docker 会**从上往下**依次在各镜像层中查找此文件。一旦找到，打开并读入内存。
  > 3. **修改文件**
  >    在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。
  > 4. **删除文件**
  >    在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。

## 2.4 构建镜像
### 2.4.1 docker commit
docker commit 命令是创建新镜像最直观的方法，其过程包含三个步骤：
> 1. 运行容器
> 2. 修改容器
> 3. 将容器保存为新的镜像

```shell
#运行容器 -it 参数的作用是以交互模式进入容器，并打开终端
docker run -it ubuntu 
#在docker容器里安装 vi
apt-get install -y vim
#在新窗口中查看当前运行的容器
docker ps
#silly_goldberg 是 Docker 为我们的容器随机分配的名字。
#执行 docker commit 命令将容器保存为新镜像,命名为 ubuntu-with-vi。
docker commit silly_goldberg ubuntu-with-vi
#从新镜像启动容器
docker run -it ubuntu-with-vi 
```

Docker 不建议用户用 docker commit构建镜像。原因如下：
> 1. 这是一种手工创建镜像的方式，容易出错，效率低且可重复性弱。比如要在 debian base 镜像中也加入 vi，还得重复前面的所有步骤。
>
> 2. 更重要的：使用者并不知道镜像是如何创建出来的，里面是否有恶意程序。也就是说无法对镜像进行审计，存在安全隐患。

### 2.4.2 Dockerfile

测试 Dockerfile 内容：

```Dockerfile
FROM ubuntu
RUN apt-get update && apt-get install -y vim
```

运行 docker build 命令构建镜像

```shell
root@ubuntu:~# pwd         ①  
/root  
root@ubuntu:~# ls          ②   
Dockerfile   
root@ubuntu:~# docker build -t ubuntu-with-vi-dockerfile .        ③   
Sending build context to Docker daemon 32.26 kB           ④   
Step 1 : FROM ubuntu           ⑤   
 ---> f753707788c5   
Step 2 : RUN apt-get update && apt-get install -y vim           ⑥   
 ---> Running in 9f4d4166f7e3             ⑦   
......   
Setting up vim (2:7.4.1689-3ubuntu1.1) ...   
 ---> 35ca89798937           ⑧    
Removing intermediate container 9f4d4166f7e3          ⑨   
Successfully built 35ca89798937           ⑩   
root@ubuntu:~#   
```

① 当前目录为 /root。

② Dockerfile 准备就绪。

③ 运行 docker build 命令，`-t` 将新镜像命名为 `ubuntu-with-vi-dockerfile`，命令末尾的 `.` 指明 build context 为当前目录。Docker 默认会从 build context 中查找 Dockerfile 文件，我们也可以通过 `-f` 参数指定 Dockerfile 的位置。

④ 从这步开始就是镜像真正的构建过程。 首先 Docker 将 build context 中的所有文件发送给 Docker daemon。build context 为镜像构建提供所需要的文件或目录。

Dockerfile 中的 ADD、COPY 等命令可以将 build context 中的文件添加到镜像。此例中，build context 为当前目录 `/root`，该目录下的所有文件和子目录都会被发送给 Docker daemon。

所以，使用 build context 就得小心了，不要将多余文件放到 build context，特别不要把 `/`、`/usr` 作为 build context，否则构建过程会相当缓慢甚至失败。

⑤ Step 1：执行 `FROM`，将 ubuntu 作为 base 镜像。
ubuntu 镜像 ID 为 f753707788c5。

⑥ Step 2：执行 `RUN`，安装 vim，具体步骤为 ⑦、⑧、⑨。

⑦ 启动 ID 为 9f4d4166f7e3 的临时容器，在容器中通过 apt-get 安装 vim。

⑧ 安装成功后，将容器保存为镜像，其 ID 为 35ca89798937。
**这一步底层使用的是类似 docker commit 的命令**。

⑨ 删除临时容器 9f4d4166f7e3。

⑩ 镜像构建成功。 

+ 以报销管理系统为例：

```shell
[root@localhost docker_test]# cat Dockerfile
FROM centos:7
ADD jexus-6.3.x-x64-BX20211121.tar.gz /home/
CMD /home/jexus/jwss
[root@localhost docker_test]# ls
Dockerfile  jexus-6.3.x-x64-BX20211121.tar.gz
[root@localhost docker_test]#
[root@localhost docker_test]# docker build -t fhbx .
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
STEP 1/3: FROM centos:7
STEP 2/3: ADD jexus-6.3.x-x64-BX20211121.tar.gz /home/
--> c916c9bee71
STEP 3/3: CMD /home/jexus/jwss
COMMIT fhbx
--> 0057dba583c
Successfully tagged localhost/fhbx:latest
0057dba583c6b21ecc2cbc027abbbf7820a9870ef161a2d08c6ab0d822d906e5
[root@localhost docker_test]#
[root@localhost docker_test]# docker run -d -p 8086:8085 localhost/fhbx
```

### 2.4.3 镜像缓存特性

* 1. 先构建如下镜像

```Dockerfile
FROM ubuntu
RUN apt-get update && apt-get install -y vim
```

* 2. 如果有如下Dockerfile，则会使用 1 中构建的镜像；构建第二步时，会Using cache

```Dockerfile
FROM ubuntu
RUN apt-get update && apt-get install -y vim
COPY testfile /
```

* 3. 如果有如下Dockerfile，则会不使用 1 中构建的镜像

```Dockerfile
FROM ubuntu
COPY testfile /
RUN apt-get update && apt-get install -y vim
```



## 2.5 最佳实践

### 2.5.1 Dockerfile 常用指令

**FROM**
指定 base 镜像。

**MAINTAINER**
设置镜像的作者，可以是任意字符串。

**COPY**
将文件从 build context 复制到镜像。
COPY 支持两种形式：`COPY src dest`  和 `COPY ["src", "dest"]`
注意：src 只能指定 build context 中的文件或目录。

**ADD**
与 COPY 类似，从 build context 复制文件到镜像。不同的是，如果 src 是归档文件（tar, zip, tgz, xz 等），文件会被自动解压到 dest。

**ENV**
设置环境变量，环境变量可被后面的指令使用。

**EXPOSE**
指定容器中的进程会监听某个端口，Docker 可以将该端口暴露出来。

**VOLUME**
将文件或目录声明为 volume。我们会在容器存储部分详细讨论。

**WORKDIR**
为后面的 RUN, CMD, ENTRYPOINT, ADD 或 COPY 指令设置镜像中的当前工作目录。

**RUN**
在容器中运行指定的命令。

**CMD**
容器启动时运行指定的命令。
Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效。CMD 可以被 docker run 之后的参数替换。

**ENTRYPOINT**
设置容器启动时运行的命令。
Dockerfile 中可以有多个 ENTRYPOINT 指令，但只有最后一个生效。CMD 或 docker run 之后的参数会被当做参数传递给 ENTRYPOINT。

 ***Dockerfile 支持以“#”开头的注释。***

> **RUN vs CMD vs ENTRYPOINT**
>
> > 1. 使用 RUN 指令安装应用和软件包，构建镜像。
> > 2. 如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。
> > 3. 如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。

### 2.5.2 镜像命名

镜像的名字由两部分组成：repository 和 tag

[image name] = [repository]:[tag]

+ 镜像命名: 

>  docker build -t ubuntu-with-vi

>  docker build -t ubuntu-with-vi:latest

+ tag 常用于描述镜像的版本信息: 

> docker tag myimage-v1.9.1 myimage:1
> docker tag myimage-v1.9.1 myimage:1.9
> docker tag myimage-v1.9.1 myimage:1.9.1
> docker tag myimage-v1.9.1 myimage:latest

+ 这种 tag 方案使镜像的版本很直观，用户在选择非常灵活：

> 1. myimage:1 始终指向 1 这个分支中最新的镜像。
> 2. myimage:1.9 始终指向 1.9.x 中最新的镜像。
> 3. myimage:latest 始终指向所有版本中最新的镜像。
> 4. 如果想使用特定版本，可以选择 myimage:1.9.1、myimage:1.9.2 或 myimage:2.0.0。

## 2.6 Registry 

### 2.6.1 公共 Registry

1. 在 Docker Hub 上注册一个账号： worden525 (）

2. 在 Docker Host 上登录

   ```shell
   [root@localhost ~]# docker login -u worden525
   Password:
   Login Succeeded
   [root@localhost ~]
   ```

3. 修改镜像的 repository 使之与 Docker Hub 账号匹配，完整的镜像名：`[username]/name:tag`，使用 `docker tag` 命令重命名镜像。

   ```shell
   [root@localhost ~]# docker tag httpd worden525/httpd:1.0
   [root@localhost ~]# docker images
   REPOSITORY               TAG           IMAGE ID          CREATED             SIZE
   docker.io/httpd          latest        dabbfbe0c57b      2 weeks ago         144 MB
   worden525/httpd          1.0           dabbfbe0c57b      2 weeks ago         144 MB
   [root@localhost ~]#
   ```

4. 通过 docker push 将镜像上传到 Docker Hub

    ```shell
   [root@localhost ~]# docker push worden525/httpd:1.0
   The push refers to a repository [docker.io/worden525/httpd]
   deefaa620a71: Mounted from library/httpd
   9cff3206f9a6: Mounted from library/httpd
   15e4bf5d0804: Mounted from library/httpd
   1da636a1aa95: Mounted from library/httpd
   2edcec3590a4: Mounted from library/httpd
   1.0: digest: sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194 size: 1365
   [root@localhost ~]#
   ```

5. 登录 <https://hub.docker.com>，在Public Repository 中就可以看到上传的镜像。

6. 这个镜像可被其他 Docker host 下载使用

   ```shell
   [root@localhost ~]# docker pull worden525/httpd:1.0
   1.0: Pulling from worden525/httpd
   a2abf6c4d29d: Pull complete
   dcc4698797c8: Pull complete
   41c22baa66ec: Pull complete
   67283bbdd4a0: Pull complete
   d982c879c57e: Pull complete
   Digest: sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194
   Status: Downloaded newer image for worden525/httpd:1.0
   [root@localhost ~]#
   ```

   

### 2.6.2 本地 Registry

1. 启动 registry 容器，参数`-d` 是后台启动容器，`-p` 将容器的 5000 端口映射到 Host 的 5000 端口，`-v` 将容器 /var/lib/registry 目录映射到 Host 的 /srv/registry，用于存放镜像数据。

   ```shell
   [root@localhost ~]# docker run -d -p 5000:5000 -v /srv/registry:/var/lib/registry --name registry registry:2
   Unable to find image 'registry:2' locally
   Trying to pull repository docker.io/library/registry ...
   2: Pulling from docker.io/library/registry
   79e9f2f55bf5: Pull complete
   0d96da54f60b: Pull complete
   5b27040df4a2: Pull complete
   e2ead8259a04: Pull complete
   3790aef225b9: Pull complete
   Digest: sha256:169211e20e2f2d5d115674681eb79d21a217b296b43374b8e39f97fcf866b375
   Status: Downloaded newer image for docker.io/registry:2
   0aea79a00457d40c0a0c85151d69ce5e103faede1e70d069a57b1e5d4d7df96b
   [root@localhost ~]#
   ```

2. 通过 `docker tag` 重命名镜像，使之与 registry 匹配

   ```shell
   [root@localhost ~]#  docker tag httpd localhost:5000/worden525/httpd:v1
   [root@localhost ~]#  docker images
   REPOSITORY                       TAG         IMAGE ID        CREATED         SIZE
   docker.io/httpd                  latest      dabbfbe0c57b    2 weeks ago     144 MB
   localhost:5000/worden525/httpd   v1          dabbfbe0c57b    2 weeks ago     144 MB
   [root@localhost ~]#
   ```

3. 通过 `docker pull` 上传镜像

   ```shell
   [root@localhost ~]# docker push  localhost:5000/worden525/httpd:v1
   The push refers to a repository [localhost:5000/worden525/httpd]
   deefaa620a71: Pushed
   9cff3206f9a6: Pushed
   15e4bf5d0804: Pushed
   1da636a1aa95: Pushed
   2edcec3590a4: Pushed
   v1: digest: sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194 size: 1365
   [root@localhost ~]# cd /srv/registry/docker/registry/v2/repositories/worden525
   [root@localhost worden525]# pwd
   /srv/registry/docker/registry/v2/repositories/worden525
   [root@localhost worden525]# ls
   httpd
   [root@localhost worden525]# cd httpd/
   [root@localhost httpd]# ls
   _layers  _manifests  _uploads
   [root@localhost httpd]#
   
   ```

4. 现在已经可通过 `docker pull` 从本地 registry 下载镜像，(先使用 `docker rmi` 从删除host中的镜像)

   ```shell
   [root@localhost httpd]# docker rmi localhost:5000/worden525/httpd:v1
   Untagged: localhost:5000/worden525/httpd:v1
   Untagged: localhost:5000/worden525/httpd@sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194
   [root@localhost httpd]#
   [root@localhost httpd]# docker pull localhost:5000/worden525/httpd:v1
   Trying to pull repository localhost:5000/worden525/httpd ...
   v1: Pulling from localhost:5000/worden525/httpd
   Digest: sha256:57c1e4ff150e2782a25c8cebb80b574f81f06b74944caf972f27e21b76074194
   Status: Downloaded newer image for localhost:5000/worden525/httpd:v1
   [root@localhost httpd]#
   ```

   

# 3 容器

## 3.1 运行容器

+ **指定容器启动时执行的命令**

> 1. CMD 指令。
> 2. ENDPOINT 指令。
> 3. 在 `docker run` 命令行中指定。

+ **查看容器**
> 1. `docker ps` 或 `docker container ls`
> 2.  `docker ps -a` 或 `docker container ls -a`
>
> > > `-a` 会显示所有状态的容器，可以看到，之前的容器已经退出了，状态为`Exited`

+ #### **容器长期运行**
> 参数 `-d` 以后台方式启动容器
```shell
[root@localhost home]# docker run --name myos -d  centos:7 /bin/bash -c "while true ; do sleep 1 ;done "
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
71edc205d0115091d942c0ff4510070319998451ae0cffd8dfb5f54ff7e21c59
[root@localhost home]# docker ps
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
CONTAINER ID  IMAGE                    COMMAND               CREATED        STATUS            PORTS       NAMES
71edc205d011  quay.io/centos/centos:7  /bin/bash -c whil...  6 seconds ago  Up 5 seconds ago              myos
[root@localhost home]#
```

+ **`docker create` 创建的容器处于 Created 状态。`docker start` 将以后台方式启动容器。 `docker run` 命令实际上是 `docker create` 和 `docker start` 的组合。**

## 3.2 进入容器

+ ##### **docker attach**

> 通过 `docker attach` 可以 attach 到容器启动命令的终端，可以看到终端的信息。
>
> 通过 Ctrl+p 然后 Ctrl+q 组合键退出 attach 终端。
>
> ``` shell
> [root@localhost home]#  docker attach 8c569f58438f
> Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
> Fri Jan  7 15:54:08 UTC 2022
> Fri Jan  7 15:54:09 UTC 2022
> Fri Jan  7 15:54:10 UTC 2022
> ```

+ ##### **docker exec**

```shell
[root@localhost ~]# docker ps
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
CONTAINER ID  IMAGE                    COMMAND               CREATED         STATUS             PORTS       NAMES
8c569f58438f  quay.io/centos/centos:7  /bin/bash -c whil...  58 minutes ago  Up 58 minutes ago              myos_date
[root@localhost ~]# docker exec -it 8c569f58438f /bin/bash
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
[root@8c569f58438f /]# ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 15:00 ?        00:00:02 /bin/bash -c while true ; do sleep 1 ; date ;done
root        7114       0  4 15:59 pts/0    00:00:00 /bin/bash
root        7153       1  0 15:59 ?        00:00:00 sleep 1
root        7154    7114  0 15:59 pts/0    00:00:00 ps -ef
[root@8c569f58438f /]#
```

> ① `-it` 以交互模式打开 pseudo-TTY，执行 bash，其结果就是打开了一个 bash 终端。
>
> ② 进入到容器中，容器的 hostname 就是其 “短ID”。
>
> ③ 可以像在普通 Linux 中一样执行命令。`ps -elf` 显示了容器启动进程`while` 以及当前的 `bash` 进程。
>
> ④ 执行 `exit` 退出容器，回到 docker host。
>
> `docker exec -it <container> bash|sh` 是执行 exec 最常用的方式。

+ ##### **attach VS exec**

> 1. attach 直接进入容器 **启动命令** 的终端，不会启动新的进程。
> 2. exec 则是在容器中打开新的终端，并且可以启动新的进程。
> 3. 如果想直接在终端中查看启动命令的输出，用 attach；其他情况使用 exec。

`docker logs`用于查看日志，`-f` 的作用与 `tail -f` 类似，能够持续打印输出。

## 3.3 容器常用操作

### 3.3.1 stop/start/restart 容器

`docker start` 会保留容器的第一次启动时的所有参数。

`docker restart` 可以重启容器，其作用就是依次执行 `docker stop` 和`docker start`。

```bash
[root@localhost ~]# docker ps
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
CONTAINER ID  IMAGE                    COMMAND               CREATED     STATUS         PORTS       NAMES
8c569f58438f  quay.io/centos/centos:7  /bin/bash -c whil...  2 days ago  Up 2 days ago              myos_date
[root@localhost ~]# docker stop 8c569f58438f
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
8c569f58438f
[root@localhost ~]# docker ps
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
CONTAINER ID  IMAGE       COMMAND     CREATED     STATUS      PORTS       NAMES
[root@localhost ~]# docker start 8c569f58438f
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
8c569f58438f
[root@localhost ~]# docker ps
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
CONTAINER ID  IMAGE                    COMMAND               CREATED     STATUS            PORTS       NAMES
8c569f58438f  quay.io/centos/centos:7  /bin/bash -c whil...  2 days ago  Up 3 minutes ago              myos_date
[root@localhost ~]#
```

启动容器时设置 `--restart` 就可以达到容器能够自动重启效果。

### 3.3.2 pause/unpause 容器

有时我们只是希望暂时让容器暂停工作一段时间，比如要对容器的文件系统打个快照，或者 dcoker host 需要使用 CPU，这时可以执行 `docker pause`。

处于暂停状态的容器不会占用 CPU 资源，直到通过 `docker unpause` 恢复运行。

### 3.3.3 删除容器

使用 docker 一段时间后，host 上可能会有大量已经退出了的容器。这些容器依然会占用 host 的文件系统资源，如果确认不会再重启此类容器，可以通过 `docker rm` 删除。

`docker rm` 一次可以指定多个容器.

如果希望批量删除所有已经退出的容器，可以执行：<font color=red>  docker rm -v $(docker ps -aq -f status=exited)  </font>

*顺便说一句：`docker rm` 是删除容器，而 `docker rmi` 是删除镜像。*

## 3.4 限制容器资源

### 3.4.1 限制内存

1. `-m` 或 `--memory`：设置内存的使用限额，例如 100M, 2G。

2. `--memory-swap`：设置 **内存+swap** 的使用限额。

>
> docker run -it -m 200M --memory-swap=300M  centos:7 
>
> 其含义是允许该容器最多使用 200M 的内存和 100M 的 swap。默认情况下，上面两组参数为 -1，即对容器内存和 swap 的使用没有限制。

> 如果在启动容器时只指定 `-m` 而不指定 `--memory-swap`，那么 `--memory-swap` 默认为 `-m` 的两倍，比如：
>
> docker run -it -m 200M centos:7 
>
> 容器最多使用 200M 物理内存和 200M swap。

> docker run -it -m 200M --memory-swap=300M progrium/stress --vm 1 --vm-bytes 280M
>
> progrium/stress容器为压力测试容器，
>
> `--vm 1`：启动 1 个内存工作线程。
>
> `--vm-bytes 280M`：每个线程分配 280M 内存。

### 3.4.2 限制CPU

通过  `--cpu-shares` 设置容器使用 CPU 的权重。如果不指定，默认值为 1024。

> docker run --name container_A -it --cpu-shares 1024 progrium/stress --cpu 1
>
> docker run --name container_B -it --cpu-shares 512 progrium/stress --cpu 1

> progrium/stress容器为压力测试容器，
>
> `--cpu` progrium/stress容器的参数，用来设置工作线程的数量。

### 3.4.3 限制Block IO

+ ##### block IO 权重

通过设置 `--blkio-weight` 参数来改变容器 block IO 的优先级。设置的是相对权重值，默认为 500。

> docker run  -it --blkio-weight 300 centos:7 
>

+ ##### 限制 bps 和 iops

bps 是 byte per second，每秒读写的数据量。
iops 是 io per second，每秒 IO 的次数。

可通过以下参数控制容器的 bps 和 iops：
`--device-read-bps`，限制读某个设备的 bps。
`--device-write-bps`，限制写某个设备的 bps。
`--device-read-iops`，限制读某个设备的 iops。
`--device-write-iops`，限制写某个设备的 iops。

> docker run -it --device-write-bps /dev/sda:300MB centos:7 
>
> > time dd if=/dev/zero of=test.dd bs=1M count=800 oflag=direct
> >
> > `oflag=direct` 指定用 direct IO 方式写文件，这样 `--device-write-bps` 才能生效。

## 3.5 实现容器的底层技术

+ #### cgroup

> cgroup 全称 Control Group。Linux 操作系统通过 cgroup 可以设置进程使用 CPU、内存 和 IO 资源的限额。
>
> docker run --name container_B -it --cpu-shares 512 progrium/stress --cpu 1
>```shell
> [root@localhost ~]# docker ps  -q
> Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
> 0aaf61fea458
> [root@localhost ~]#
> [root@localhost ~]# cat /sys/fs/cgroup/cpu/machine.slice/libpod-0aaf61fea4589887b282e690c03a3bd0264b0a3579baed78d11791f4093092a3.scope/cpu.shares
> 512
> [root@localhost ~]#
> ```
> 
> 同样的，/sys/fs/cgroup/memory/docker 和 /sys/fs/cgroup/blkio/docker 中保存的是内存以及 Block IO 的 cgroup 配置。

+ #### namespace

namespace 实现了容器间资源的隔离。Linux 使用了六种 namespace，分别对应六种资源：Mount、UTS、IPC、PID、Network 和 User.

> 1. Mount namespace：让容器看上去拥有整个**文件系统**，容器有自己的 `/` 目录，可以执行 `mount` 和 `umount` 命令；
> 2. UTS namespace：让容器有自己的 **hostname**，通过 `-h` 或 `--hostname` 参数设置；
> 3. IPC namespace：让容器拥有自己的**共享内存和信号量**（semaphore）来实现进程间通信，而不会与 host 和其他容器的 IPC 混在一起。
> 4. PID namespace：容器拥有自己独立的**一套 PID**，核心进程PID为1；
> 5. Network namespace：让容器拥有自己独立的**网卡、IP、路由等资源**；
> 6. User namespace：让容器能够管理**自己的用户**，host 不能看到容器中创建的用户。

+ #### UnionFS（联合文件系统）

> #### Copy-on-write
>
> OverlayFS



## 3.6 容器网络

### 3.6.1 none、host、bridge三个默认网络

Docker 安装时会自动在 host 上创建三个网络，我们可用 `docker network ls` 命令查看：
```shell
[root@localhost ~]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
b3729de88c34        bridge              bridge              local
2e434f2fc7e2        host                host                local
f0504dd10503        none                null                local
[root@localhost ~]#
```

+ ### none 网络

none 网络的容器除了 lo，没有其他任何网卡。容器创建时，可以通过 `--network=none` 指定使用 none 网络。

```shell
[root@localhost ~]# docker run -it --network=none  busybox
/ # ip l
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
/ #
[root@localhost ~]#
```

+ ### host 网络

host 网络的容器共享 Docker host 的网络栈，网络配置与 host 完全一样,通过 `--network=host` 指定。直接使用 Docker host 的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择 host 网络。

```shell
[root@localhost ~]# docker run -it --network=host  busybox
/ # ip l
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast qlen 1000
    link/ether 00:15:5d:1f:fc:0c brd ff:ff:ff:ff:ff:ff
3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue
    link/ether 02:42:25:21:d5:81 brd ff:ff:ff:ff:ff:ff
7: vethbc028b9@if6: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue master docker0
    link/ether 56:f7:91:6a:4a:40 brd ff:ff:ff:ff:ff:ff
13: veth8b87bf0@if12: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue master docker0
    link/ether 8a:3f:81:71:02:36 brd ff:ff:ff:ff:ff:ff
/ #
[root@localhost ~]#
```

+ ### bridge 网络

查看网桥：`brctl  show`

```shell
[root@localhost ~]# brctl  show
bridge name     bridge id               STP enabled     interfaces
docker0         8000.02422521d581       no
[root@localhost ~]# docker run -d  busybox /bin/sh -c "while true ; do sleep 1 ;done "
6bee24c79d9d4146769f59c5f1bc0d1be4f1dca1dec4ae3eee706ec104b00a3b
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
6bee24c79d9d        busybox             "/bin/sh -c 'while..."   6 seconds ago       Up 5 seconds                            reverent_shirley
[root@localhost ~]#
[root@localhost ~]# brctl  show
bridge name     bridge id               STP enabled     interfaces
docker0         8000.02422521d581       no              vethc368848
[root@localhost ~]#
[root@localhost ~]# docker exec -it 6bee24c79d9d /bin/sh
/ # ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
30: eth0@if31: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.2/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe11:2/64 scope link
       valid_lft forever preferred_lft forever
/ #
/ # route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         172.17.0.1      0.0.0.0         UG    0      0        0 eth0
172.17.0.0      *               255.255.0.0     U     0      0        0 eth0
/ #
[root@localhost ~]#
```

通过 `docker network inspect bridge` 看一下 bridge 网络的配置信息:

```shell
[root@localhost ~]# docker network inspect bridge
[
    {
        "Name": "bridge",
        "Id": "b3729de88c34868235f98794d2c24b4ffa18a67bfd89523b89df959a602154bd",
        "Created": "2022-01-02T13:04:57.497663647+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Containers": {
            "2c107d6d3028a7443a42e5e882bf917c099fb98546f82379f2769e9a61cf7e54": {
                "Name": "heuristic_bardeen",
                "EndpointID": "0935bffa05af4681e3808bd0b9ed8fe0f4eda363b1ec668f5928c20909ffcf1d",
                "MacAddress": "02:42:ac:11:00:02",
                "IPv4Address": "172.17.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {
            "com.docker.network.bridge.default_bridge": "true",
            "com.docker.network.bridge.enable_icc": "true",
            "com.docker.network.bridge.enable_ip_masquerade": "true",
            "com.docker.network.bridge.host_binding_ipv4": "0.0.0.0",
            "com.docker.network.bridge.name": "docker0",
            "com.docker.network.driver.mtu": "1500"
        },
        "Labels": {}
    }
]
[root@localhost ~]#
```

容器创建时，docker 会自动从 172.17.0.0/16 中分配一个 IP，这里 16 位的掩码保证有足够多的 IP 可以供容器使用。

### 3.6.2 自定义容器网络

Docker 提供三种 user-defined 网络驱动：bridge, overlay 和 macvlan。overlay 和 macvlan 用于创建跨主机的网络，此处演示bridge。

+ 创建并使用新网络

```shell
[root@localhost ~]# docker network create --driver bridge my_net
e7c6e0b50213157e2514a3c0616be0ffcc3a0f0828c760601a225a8286b966fe
[root@localhost ~]# 
[root@localhost ~]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
b3729de88c34        bridge              bridge              local
2e434f2fc7e2        host                host                local
e7c6e0b50213        my_net              bridge              local
f0504dd10503        none                null                local
[root@localhost ~]#
[root@localhost ~]# brctl  show
bridge name     bridge id               STP enabled     interfaces
br-e7c6e0b50213         8000.0242c5af78fa       no
docker0         8000.02422521d581       no
[root@localhost ~]#
[root@localhost ~]# docker run -d  --network=my_net busybox /bin/sh -c "while true ; do sleep 1 ;done "
37a6ddc46be1370253313be449725d063555169ee0ef802faed801363e3e4074
[root@localhost ~]# docker exec -it 37a6ddc46be1 /bin/sh
/ # ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
33: eth0@if34: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.2/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe12:2/64 scope link
       valid_lft forever preferred_lft forever
/ # route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         172.18.0.1      0.0.0.0         UG    0      0        0 eth0
172.18.0.0      *               255.255.0.0     U     0      0        0 eth0
/ #
[root@localhost ~]#

```

+ 查看新网络配置，并设置网络

```shell
[root@localhost ~]# docker network inspect  my_net
[
    {
        "Name": "my_net",
        "Id": "e7c6e0b50213157e2514a3c0616be0ffcc3a0f0828c760601a225a8286b966fe",
        "Created": "2022-01-17T00:45:38.739641533+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Containers": {
            "37a6ddc46be1370253313be449725d063555169ee0ef802faed801363e3e4074": {
                "Name": "sad_poincare",
                "EndpointID": "37a56591c672b6869158ddbd6655a7cfd061350ab961be677ad817a9afc96e65",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]
[root@localhost ~]#
[root@localhost ~]# docker network create --driver bridge  --subnet 172.22.1.0/24 --gateway 172.22.1.1 my_net2
e3947fe7f93b05ee237c3b69638d92532a9cbb6fedb0555b7c0b48dc7f62e167
[root@localhost ~]# docker network inspect  my_net2
[
    {
        "Name": "my_net2",
        "Id": "e3947fe7f93b05ee237c3b69638d92532a9cbb6fedb0555b7c0b48dc7f62e167",
        "Created": "2022-01-17T00:55:40.521742955+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.22.1.0/24",
                    "Gateway": "172.22.1.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]
[root@localhost ~]#

```

+ 使用`--ip`指定窗口的IP

```shell
[root@localhost ~]# docker run -it --network=my_net2 --ip 172.22.1.34 busybox
/ # ip  a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
38: eth0@if39: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue
    link/ether 02:42:ac:16:01:22 brd ff:ff:ff:ff:ff:ff
    inet 172.22.1.34/24 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe16:122/64 scope link
       valid_lft forever preferred_lft forever
/ #
[root@localhost ~]#
```

注：**只有使用 `--subnet` 创建的网络才能指定静态 IP**。

### 3.6.3 容器之间的连通性

+ 1. 同一网络中的容器、网关之间都是可以通信的；
+ 2. 不同网络中的容器是不可以通信的；

```shell
[root@localhost ~]# ip r
default via 192.168.1.1 dev eth0 proto static metric 100
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1
172.18.0.0/16 dev br-e7c6e0b50213 proto kernel scope link src 172.18.0.1
172.22.1.0/24 dev br-e3947fe7f93b proto kernel scope link src 172.22.1.1
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.241 metric 100
[root@localhost ~]#
[root@localhost ~]# sysctl -a 2>/dev/zero |  grep net.ipv4.ip_forward
net.ipv4.ip_forward = 1
net.ipv4.ip_forward_use_pmtu = 0
[root@localhost ~]# #iptables DROP 掉了网桥 docker0 与 br-e3947fe7f93b / br-e7c6e0b50213 之间双向的流量。
[root@localhost ~]# iptables-save |grep DOCKER-ISOLATION   
:DOCKER-ISOLATION - [0:0]
-A FORWARD -j DOCKER-ISOLATION
-A DOCKER-ISOLATION -i br-e7c6e0b50213 -o br-e3947fe7f93b -j DROP
-A DOCKER-ISOLATION -i br-e3947fe7f93b -o br-e7c6e0b50213 -j DROP
-A DOCKER-ISOLATION -i docker0 -o br-e3947fe7f93b -j DROP
-A DOCKER-ISOLATION -i br-e3947fe7f93b -o docker0 -j DROP
-A DOCKER-ISOLATION -i docker0 -o br-e7c6e0b50213 -j DROP
-A DOCKER-ISOLATION -i br-e7c6e0b50213 -o docker0 -j DROP
-A DOCKER-ISOLATION -j RETURN
[root@localhost ~]#

```

+ 3. 不同网络中的容器，通过`docker network connect` 命令增加网卡，使之同网络。

```shell
[root@localhost ~]# docker run -d --name busybox_1 --network=my_net busybox /bin/sh -c "while true ; do sleep 1 ;done "
19516570d51e01767ad9371f63d7194add430191cf09625f5091fc5e83f46719
[root@localhost ~]# docker run -d --name busybox_2 --network=my_net2 --ip 172.22.1.34  busybox /bin/sh -c "while true ; do sleep 1 ;done "
2cfb80d5864ae67565ef57c2de68544d7eb7309f62c3c419c6fe69d7d701a511
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES
2cfb80d5864a        busybox             "/bin/sh -c 'while..."   36 seconds ago       Up 35 seconds                           busybox_2
19516570d51e        busybox             "/bin/sh -c 'while..."   About a minute ago   Up About a minute                       busybox_1
[root@localhost ~]#
[root@localhost ~]#
[root@localhost ~]# docker exec -it busybox_1 /bin/sh
/ # ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
44: eth0@if45: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.2/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe12:2/64 scope link
       valid_lft forever preferred_lft forever
/ # ping 172.22.1.34
PING 172.22.1.34 (172.22.1.34): 56 data bytes
^C
--- 172.22.1.34 ping statistics ---
2 packets transmitted, 0 packets received, 100% packet loss
/ #
[root@localhost ~]#
[root@localhost ~]# docker network connect my_net2 busybox_1
[root@localhost ~]#
[root@localhost ~]# docker exec -it busybox_1 /bin/sh
/ # ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
44: eth0@if45: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.2/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe12:2/64 scope link
       valid_lft forever preferred_lft forever
48: eth1@if49: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue
    link/ether 02:42:ac:16:01:02 brd ff:ff:ff:ff:ff:ff
    inet 172.22.1.2/24 scope global eth1
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe16:102/64 scope link
       valid_lft forever preferred_lft forever
/ # ping 172.22.1.34
PING 172.22.1.34 (172.22.1.34): 56 data bytes
64 bytes from 172.22.1.34: seq=0 ttl=64 time=0.144 ms
64 bytes from 172.22.1.34: seq=1 ttl=64 time=0.105 ms
64 bytes from 172.22.1.34: seq=2 ttl=64 time=0.110 ms
^C
--- 172.22.1.34 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.105/0.119/0.144 ms
/ #
[root@localhost ~]#


```

+ 4. 通过joined 容器进行互通访问 

```shell
[root@localhost ~]# docker run -d -it --name=web1 httpd
4da641e77405b66371652b458e044e29614d6158f4905753b1cc8b67613f8961
[root@localhost ~]# docker run -it --network=container:web1 busybox
/ # wget http://127.0.0.1/
Connecting to 127.0.0.1 (127.0.0.1:80)
saving to 'index.html'
index.html           100% |*****************************************************************************************|    45  0:00:00 ETA
'index.html' saved
/ #
[root@localhost ~]#
```

busybox 和 web1 的网卡 mac 地址与 IP 完全一样，它们共享了相同的网络栈。busybox 可以直接用 127.0.0.1 访问 web1 的 http 服务。joined 容器非常适合以下场景：

> 1. 不同容器中的程序希望通过 loopback 高效快速地通信，比如 web server 与 app server。
> 2. 希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。

+ 5. Docker DNS Server

> 在 user-defined 网络中使用name进行通信，默认的 bridge 网络是无法使用 DNS 的。

```shell
[root@localhost ~]# docker run -d --name busybox_1 --network=my_net busybox /bin/sh -c "while true ; do sleep 1 ;done "
e56cee47a8287f44170d67ff921ef47115b5a8a2c6448732e59a99a4b621974f
[root@localhost ~]# docker run -it --name busybox_2 --network=my_net busybox
/ # ping busybox_1
PING busybox_1 (172.18.0.2): 56 data bytes
64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.106 ms
64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.162 ms
^C
--- busybox_1 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max = 0.106/0.134/0.162 ms
/ # ping busybox_2
PING busybox_2 (172.18.0.3): 56 data bytes
64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.033 ms
64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.104 ms
^C
--- busybox_2 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max = 0.033/0.068/0.104 ms
/ #
[root@localhost ~]#
```

### 3.6.4 外部世界访问容器--端口映射

> 容器启动时通过`-p`参数映射到 host 的某个端口，也可在 `-p` 中指定映射到 host 某个特定端口，

```shell
[root@localhost ~]# docker run -d -p 80 httpd
6945559bb8aa3736f8b749be6f0f3620b138321e73b80f2a5af11a10636ac472
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                   NAMES
6945559bb8aa        httpd               "httpd-foreground"   5 seconds ago       Up 5 seconds        0.0.0.0:32768->80/tcp   pedantic_wright
[root@localhost ~]#
[root@localhost ~]# docker port 6945559bb8aa
80/tcp -> 0.0.0.0:32768
[root@localhost ~]# 
[root@localhost ~]# ps aux | grep 32768 | grep docker-proxy
root       2552  0.0  0.1 108932  2628 ?        Sl   23:13   0:00 /usr/libexec/docker/docker-proxy-current -proto tcp -host-ip 0.0.0.0 -host-port 32768 -container-ip 172.17.0.2 -container-port 80
[root@localhost ~]#
[root@localhost ~]# docker run -d -p 8081:80 httpd
da68657bf01b1331d937002d9cd610170873d3496198c72f3c0e3a15fe96b749
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                   NAMES
da68657bf01b        httpd               "httpd-foreground"   9 seconds ago       Up 7 seconds        0.0.0.0:8081->80/tcp    awesome_leakey
6945559bb8aa        httpd               "httpd-foreground"   5 minutes ago       Up 5 minutes        0.0.0.0:32768->80/tcp   pedantic_wright
[root@localhost ~]# netstat -npa | grep 8081
tcp6       0      0 :::8081                 :::*                    LISTEN      2961/docker-proxy-c
[root@localhost ~]# ps aux | grep docker-proxy
root       1024  0.1  1.4 827036 39184 ?        Ssl  21:23   0:09 /usr/bin/dockerd-current --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current --default-runtime=docker-runc --exec-opt native.cgroupdriver=systemd --userland-proxy-path=/usr/libexec/docker/docker-proxy-current --init-path=/usr/libexec/docker/docker-init-current --seccomp-profile=/etc/docker/seccomp.json --selinux-enabled --log-driver=journald --signature-verification=false --storage-driver overlay2
root       2552  0.0  0.0 108932  2632 ?        Sl   23:13   0:00 /usr/libexec/docker/docker-proxy-current -proto tcp -host-ip 0.0.0.0 -host-port 32768 -container-ip 172.17.0.2 -container-port 80
root       2961  0.0  0.0 108932  2632 ?        Sl   23:19   0:00 /usr/libexec/docker/docker-proxy-current -proto tcp -host-ip 0.0.0.0 -host-port 8081 -container-ip 172.17.0.3 -container-port 80
root       3530  0.0  0.0 112660   976 pts/0    R+   23:20   0:00 grep --color=auto docker-proxy
[root@localhost ~]#

```

## 3.7 容器存储

> Docker 为容器提供了两种存放数据的资源：
>
> 1. 由 storage driver 管理的镜像层和容器层。
> 2. Data Volume。

### 3.7.1 storage driver

通过`docker info`查看CentOS用的存储驱动是overlay2，底层文件系统是xfs，各层数据存放在（Docker Root Dir）/var/lib/docker

```shell
[root@localhost ~]# docker info
Containers: 7
 Running: 1
 Paused: 0
 Stopped: 6
Images: 7
Server Version: 1.13.1
Storage Driver: overlay2
 Backing Filesystem: xfs
 Supports d_type: true
 Native Overlay Diff: true
Logging Driver: journald
Cgroup Driver: systemd
Plugins:
 Volume: local
 Network: bridge host macvlan null overlay
Swarm: inactive
Runtimes: docker-runc runc
Default Runtime: docker-runc
Init Binary: /usr/libexec/docker/docker-init-current
containerd version:  (expected: aa8187dbd3b7ad67d8e5e3a15115d3eef43a7ed1)
runc version: 66aedde759f33c190954815fb765eedc1d782dd9 (expected: 9df8b306d01f59d3a8029be411de015b7304dd8f)
init version: fec3683b971d9c3ef73f284f176672c44b448662 (expected: 949e6facb77383876aeff8a6944dde66b3089574)
Security Options:
 seccomp
  WARNING: You're not using the default seccomp profile
  Profile: /etc/docker/seccomp.json
 selinux
Kernel Version: 3.10.0-693.el7.x86_64
Operating System: CentOS Linux 7 (Core)
OSType: linux
Architecture: x86_64
Number of Docker Hooks: 3
CPUs: 1
Total Memory: 3.281 GiB
Name: localhost.localdomain
ID: ZRXW:S7BI:OVLR:GXYH:RISI:3SBF:TQDN:XHFL:NGEP:WSZA:ATJH:DISG
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Username: worden525
Registry: https://index.docker.io/v1/
Experimental: false
Insecure Registries:
 127.0.0.0/8
Live Restore Enabled: false
Registries: docker.io (secure)
[root@localhost ~]#

```

### 3.7.2 容器使用Host目录

Data Volume 本质上是 Docker Host 文件系统中的目录或文件，能够直接被 mount 到容器的文件系统中。Data Volume 有以下特点：

> 1. Data Volume 是目录或文件，而非没有格式化的磁盘（块设备）。
> 2. 容器可以读写 volume 中的数据。
> 3. volume 数据可以被永久的保存，即使使用它的容器已经销毁。

#### 3.7.2.1 bind mount

bind mount是将 host 上已存在的目录或文件 mount 到容器。-v 可以带权限参数，比如 ro（只读）。

```shell
[root@localhost home]# mkdir htdocks
[root@localhost home]# echo "12345" >htdocks/123.html
[root@localhost home]# docker run -d -p 80:80 -v /home/htdocks:/usr/local/apache2/htdocs httpd
0706fb882a78ab5bafd3e137da0fce7fca4b8300c40e2ee21a9452f43b392d69
[root@localhost home]# docker ps
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMES
0706fb882a78        httpd               "httpd-foreground"   6 seconds ago       Up 6 seconds        0.0.0.0:80->80/tcp   agitated_leavitt
[root@localhost home]# docker exec -it 0706fb882a78 bash
root@0706fb882a78:/usr/local/apache2# ls
bin  build  cgi-bin  conf  error  htdocs  icons  include  logs modules
root@0706fb882a78:/usr/local/apache2# cd htdocs/
root@0706fb882a78:/usr/local/apache2/htdocs# ls
ls: cannot open directory '.': Permission denied
root@0706fb882a78:/usr/local/apache2/htdocs#
exit
[root@localhost home]# docker kill 0706fb882a78
0706fb882a78
[root@localhost home]# 
[root@localhost home]# 
[root@localhost home]# docker run -d -p 80:80 -v /home/htdocks:/usr/local/apache2/htdocs:Z httpd
12eb7a1911ad7233d97b6fa31f739d7d88d1dc0fb805140c85d1794c712dd633
[root@localhost home]# docker ps
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMES
12eb7a1911ad        httpd               "httpd-foreground"   18 seconds ago      Up 17 seconds       0.0.0.0:80->80/tcp   amazing_curie
[root@localhost home]# docker exec -it 12eb7a1911ad bash
root@12eb7a1911ad:/usr/local/apache2# ls
bin  build  cgi-bin  conf  error  htdocs  icons  include  logs modules
root@12eb7a1911ad:/usr/local/apache2# cd htdocs/
root@12eb7a1911ad:/usr/local/apache2/htdocs# ls
123.html
root@12eb7a1911ad:/usr/local/apache2/htdocs#
exit
[root@localhost home]# curl http://127.0.0.1/123.html
12345
[root@localhost home]#

```

> 注意：目录 挂载报`Permission denied`，可能是由于centos7中安全模块selinux把权限禁掉了。
>
> > 1. 可以通过 `setenforce 0` 关闭selinux；
> >2. 在运行`docker run`时加 --privileged=true；
> > 3. 在运行`docker run`时，-v 后权限加 Z，见上面的示例；
> > 4. 使用`chcon` 命令添加linux规则，把要挂载的目录添加到selinux白名单；例如`chcon -Rt svirt_sandbox_file_t /home/redis/redis.conf`

通过`docker inspect`命令，查看容器“Mounts”那一部分，我们可以得到这bind mount的信息。

```shell
[root@localhost home]# docker inspect 12eb7a1911ad
........
        "Mounts": [
            {
                "Type": "bind",
                "Source": "/home/htdocks",
                "Destination": "/usr/local/apache2/htdocs",
                "Mode": "Z",
                "RW": true,
                "Propagation": "rprivate"
            }
        ],
........
```

bind mount 有不足的地方：bind mount 需要指定 host 文件系统的特定路径，这就限制了容器的可移植性，当需要将容器迁移到其他 host，而该 host 没有要 mount 的数据或者数据不在相同的路径时，操作会失败。

#### 3.7.2.2 docker managed volume

+ docker managed volume 与 bind mount 在使用上的最大区别是不需要指定 mount 源，指明 mount point 就行了。

```shell
[root@localhost home]# docker run -d -p 80:80 -v /usr/local/apache2/htdocs httpd
a1bd4e41a4f52535df356b8757bc847f233249ea53ccd01df0e8d4c39d743718
[root@localhost home]# docker ps
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                NAMES
a1bd4e41a4f5        httpd               "httpd-foreground"   9 seconds ago       Up 8 seconds        0.0.0.0:80->80/tcp   kind_swartz
[root@localhost home]# docker inspect a1bd4e41a4f5
........
        "Mounts": [
            {
                "Type": "volume",
                "Name": "387cb0ce62b80e3d4b391d91b21bec695cf5b83bd5c55d7a4f35e360a92dd80c",
                "Source": "/var/lib/docker/volumes/387cb0ce62b80e3d4b391d91b21bec695cf5b83bd5c55d7a4f35e360a92dd80c/_data",
                "Destination": "/usr/local/apache2/htdocs",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ],
........
[root@localhost home]# docker volume  ls
DRIVER              VOLUME NAME
local               387cb0ce62b80e3d4b391d91b21bec695cf5b83bd5c55d7a4f35e360a92dd80c
[root@localhost home]# docker volume  inspect 387cb0ce62b80e3d4b391d91b21bec695cf5b83bd5c55d7a4f35e360a92dd80c
[
    {
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/387cb0ce62b80e3d4b391d91b21bec695cf5b83bd5c55d7a4f35e360a92dd80c/_data",
        "Name": "387cb0ce62b80e3d4b391d91b21bec695cf5b83bd5c55d7a4f35e360a92dd80c",
        "Options": {},
        "Scope": "local"
    }
]
[root@localhost home]#
[root@localhost home]# ls /var/lib/docker/volumes/387cb0ce62b80e3d4b391d91b21bec695cf5b83bd5c55d7a4f35e360a92dd80c/_data
index.html
[root@localhost home]# cat  /var/lib/docker/volumes/387cb0ce62b80e3d4b391d91b21bec695cf5b83bd5c55d7a4f35e360a92dd80c/_data/index.html
<html><body><h1>It works!</h1></body></html>
[root@localhost home]# 
[root@localhost home]# echo "12345678" > /var/lib/docker/volumes/387cb0ce62b80e3d4b391d91b21bec695cf5b83bd5c55d7a4f35e360a92dd80c/_data/index.html
You have new mail in /var/spool/mail/root
[root@localhost home]# curl http://127.0.0.1/
12345678
[root@localhost home]#
```

+ docker managed volume下更新内容方式

> 1.  使用`docker cp`命令把host文件拷贝进容器里
>
> ```shell
> [root@localhost htdocks]# docker cp /home/htdocks/123.html 0123da548429:/usr/local/apache2/htdocs
> [root@localhost htdocks]# ls "/var/lib/docker/volumes/b184a7544bf15551cba4ed61216c8574fad2bea70a661c4a86b74f9527511a1b/_data"
> 123.html  index.html
> [root@localhost htdocks]#
> ```
>
> 2. 直接修改host里volume位置下的文件

+ 孤儿 volume，可以用 `docker volume rm` 删除

批量删除孤儿 volume，可以执行：`docker volume rm $(docker volume ls -q)`


#### 3.7.2.3 bind mount和docker managed volume对比

1. 相同点：两者都是 host 文件系统中的某个路径。
2. 不同点：

|                        |                   bind mount |        docker managed volume |
| ---------------------: | ---------------------------: | ---------------------------: |
|            volume 位置 |                   可任意指定 |  /var/lib/docker/volumes/... |
| 对已有mount point 影响 |          隐藏并替换为 volume |        原有数据复制到 volume |
|       是否支持单个文件 |                         支持 |           不支持，只能是目录 |
|               权限控制 | 可设置为只读，默认为读写权限 |         无控制，均为读写权限 |
|                 移植性 |  移植性弱，与 host path 绑定 | 移植性强，无需指定 host 目录 |
|               数据共享 |  可在容器间共享数据 | 不可共享数据 |

### 3.7.3 容器间共享数据

#### 3.7.3.1 volume container

volume container 是专门为其他容器提供 volume 的容器。它提供的卷可以是 bind mount，也可以是 docker managed volume。

```shell
[root@localhost home]# docker create --name vc_data -v /home/htdocks:/usr/local/apache2/htdocs -v /other/useful/tools busybox
2254c8fb32b4670820b3e811f6f7c344ce00059485658c58be31552f6d841724
[root@localhost home]#  docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
2254c8fb32b4        busybox             "sh"                     4 seconds ago       Created                                 vc_data
[root@localhost home]#
```

其他容器可以通过 `--volumes-from` 使用 `vc_data` 这个 volume container：

```shell
[root@localhost home]# docker run --name web1 -d -p 80 --volumes-from vc_data httpd
a17c7231db7c09333c8a21ee506fa11e0ea075b48b9c9027e00940481c5a2765
[root@localhost home]# docker run --name web2 -d -p 80 --volumes-from vc_data httpd
799bafbdaf33c217aac875f1d0c5ac66be7b52ee480cbb08f740c46923e7e142
[root@localhost home]# docker run --name web3 -d -p 80 --volumes-from vc_data httpd
d1aab935170ccf6e7b320517e0da9e65b0a950e40649433e043e578746deab08
[root@localhost home]# docker ps
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                   NAMES
d1aab935170c        httpd               "httpd-foreground"   4 seconds ago       Up 3 seconds        0.0.0.0:32771->80/tcp   web3
799bafbdaf33        httpd               "httpd-foreground"   12 seconds ago      Up 11 seconds       0.0.0.0:32770->80/tcp   web2
a17c7231db7c        httpd               "httpd-foreground"   21 seconds ago      Up 20 seconds       0.0.0.0:32769->80/tcp   web1
[root@localhost home]#
[root@localhost home]# echo "This from vc_data" > /home/htdocks/index.html
[root@localhost home]# curl 127.0.0.1:32771
This from vc_data
[root@localhost home]# curl 127.0.0.1:32770
This from vc_data
[root@localhost home]# curl 127.0.0.1:32769
This from vc_data
[root@localhost home]#
```

可以通过`docker inspect `查看，这web1、web2、web3三个容器的Mounts信息与vc_data容器的一致。

volume container 的特点：

> 1. 与 bind mount 相比，不必为每一个容器指定 host path，所有 path 都在 volume container 中定义好了，容器只需与 volume container 关联，**实现了容器与 host 的解耦**。
> 2. 使用 volume container 的容器其 mount point 是一致的，有利于配置的规范和标准化，但也带来一定的局限，使用时需要综合考虑。

#### 3.7.3.2 data-packed volume container

data-packed volume container其原理是将数据打包到镜像中，然后通过 docker managed volume 共享。

+ 1. **制作内容镜像**

```shell
[root@localhost datapacked]# find
.
./Dockerfile
./htdocs
./htdocs/123.html
./htdocs/index.html
[root@localhost datapacked]# cat ./htdocs/index.html
This from vc_data
[root@localhost datapacked]# cat Dockerfile
FROM busybox
ADD htdocs /usr/local/apache2/htdocs
VOLUME /usr/local/apache2/htdocs
[root@localhost datapacked]# docker build -t datapacked .
Sending build context to Docker daemon 4.608 kB
Step 1/3 : FROM busybox
 ---> beae173ccac6
Step 2/3 : ADD htdocs /usr/local/apache2/htdocs
 ---> fd4d6ac5ac08
Removing intermediate container 40c9fb6afcab
Step 3/3 : VOLUME /usr/local/apache2/htdocs
 ---> Running in b8fbcb951520
 ---> d4e1a731b8a6
Removing intermediate container b8fbcb951520
Successfully built d4e1a731b8a6
[root@localhost datapacked]#
```

+ 2. 创建data-packed volume container

```shell
[root@localhost datapacked]# docker create --name vc_data datapacked
3a1e840e1d5e262845ee3ec1a5af0f35acfd3e17b178663812f735841fd9cd34
[root@localhost datapacked]#
```

+ 3. 使用 data-packed volume container

```shell
[root@localhost datapacked]# docker run -d -p 80:80 --volumes-from vc_data httpd
ecece46e3f1b28465b544fe0e5399f7e763aae9e8bb83d54bc6176c1d258895c
[root@localhost datapacked]# curl 127.0.0.1
This from vc_data
[root@localhost datapacked]#
```

data-packed volume container 是自包含的，不依赖 host 提供数据，具有很强的移植性，非常适合 **只使用** 静态数据的场景，比如应用的配置信息、web server 的静态文件等。



# 4 多主机管理

略

# 5 容器网络

## 5.1 跨主机网络概述

跨主机网络方案包括：

> 1. docker 原生的 overlay 和 macvlan。
> 2. 第三方方案：常用的包括 flannel、weave 和 calico。

libnetwork 以及 CNM:

>  libnetwork 是 docker 容器网络库，最核心的内容是其定义的 Container Network Model (CNM)，这个模型对容器网络进行了抽象，由以下三类组件组成：Sandbox[^Sandbox说明] 、Endpoint [^Endpoint说明]、Network[^Network说明]

<img src="http://mmbiz.qpic.cn/mmbiz_png/Hia4HVYXRicqHpH8y0uwPo7xIHs4UP99pxRUShjX1RE8FkMfj8rDvslmzx0jYlUqttwkgjJODl91NZfMFYr9nMHA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" />



## 5.2 Overlay 网络

> 1. 为支持容器跨主机通信，Docker 提供了 overlay driver，使用户可以创建基于 VxLAN 的 overlay 网络。
> 2. Docerk overlay 网络需要一个 key-value 数据库用于保存网络状态信息，包括 Network、Endpoint、IP 等。Consul、Etcd 和 ZooKeeper 都是 Docker 支持的 key-vlaue 软件，我们这里使用 Consul。
>

### 5.2.1准备Overlay环境

+ 在一台docker主机上以容器方式运行 Consul：

> docker run -d -p 8500:8500 -h consul --name consul progrium/consul -server -bootstrap

+ 在其它docker主机上，修改docker.service (/usr/lib/systemd/system/docker.service)

  在192.168.1.242、192.168.1.243上修改。

```shell
[Unit]
Description=Docker Application Container Engine
Documentation=http://docs.docker.com
After=network.target
Wants=docker-storage-setup.service
Requires=docker-cleanup.timer

[Service]
Type=notify
NotifyAccess=main
EnvironmentFile=-/run/containers/registries.conf
EnvironmentFile=-/etc/sysconfig/docker
EnvironmentFile=-/etc/sysconfig/docker-storage
EnvironmentFile=-/etc/sysconfig/docker-network
Environment=GOTRACEBACK=crash
Environment=DOCKER_HTTP_HOST_COMPAT=1
Environment=PATH=/usr/libexec/docker:/usr/bin:/usr/sbin
ExecStart=/usr/bin/dockerd-current \
          --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current \
          --default-runtime=docker-runc \
          --exec-opt native.cgroupdriver=systemd \
          --userland-proxy-path=/usr/libexec/docker/docker-proxy-current \
          --init-path=/usr/libexec/docker/docker-init-current \
          --seccomp-profile=/etc/docker/seccomp.json \
          -H tcp://0.0.0.0:2376 \
          --cluster-store=consul://192.168.1.241:8500 \
          --cluster-advertise=eth0:2376 \
          $OPTIONS \
          $DOCKER_STORAGE_OPTIONS \
          $DOCKER_NETWORK_OPTIONS \
          $ADD_REGISTRY \
          $BLOCK_REGISTRY \
          $INSECURE_REGISTRY \
          $REGISTRIES
ExecReload=/bin/kill -s HUP $MAINPID
LimitNOFILE=1048576
LimitNPROC=1048576
LimitCORE=infinity
TimeoutStartSec=0
Restart=on-abnormal
KillMode=process

[Install]
WantedBy=multi-user.target

```

+ 重启docker服务
+ 访问consul，相看节点注册 情况

> http://192.168.1.241:8500/ui/#/dc1/kv/docker/nodes/

### 5.2.2 创建 overlay 网络

+ 在192.168.1.242上创建 一个overlay网络

```shell
[root@Docker2 ~]# docker -H 127.0.0.1:2376 network create -d overlay ov_net1
b6848140b7b82853f7d4471a857a41ff6e5654e360f106b9f4d95807a786167a
[root@Docker2 ~]# docker -H 127.0.0.1:2376 network ls
NETWORK ID          NAME                DRIVER              SCOPE
c5d098178e11        bridge              bridge              local
8d7d368667e5        host                host                local
dd0baa7e09a7        none                null                local
b6848140b7b8        ov_net1             overlay             global
[root@Docker2 ~]# #注意到 ov_net1 的 SCOPE 为 global
[root@Docker2 ~]#
[root@Docker2 ~]# docker -H 127.0.0.1:2376 run -itd --name bbox1 --network ov_net1 busybox
Unable to find image 'busybox:latest' locally
Trying to pull repository docker.io/library/busybox ...
latest: Pulling from docker.io/library/busybox
009932687766: Pull complete
Digest: sha256:afcc7f1ac1b49db317a7196c902e61c6c3c4607d63599ee1a82d702d249a0ccb
Status: Downloaded newer image for docker.io/busybox:latest
9d59b2a0479e5e253353958a7de3ea3fccc87c14aae9707154caee7a2c19f950
[root@Docker2 ~]#
[root@Docker2 ~]# docker -H 127.0.0.1:2376 exec bbox1 ip r
default via 172.18.0.1 dev eth1
10.0.0.0/24 dev eth0 scope link  src 10.0.0.2
172.18.0.0/16 dev eth1 scope link  src 172.18.0.2
[root@Docker2 ~]# #bbox1 有两个网络接口 eth0 和 eth1
[root@Docker2 ~]#
[root@Docker2 ~]# docker -H 127.0.0.1:2376 network ls
NETWORK ID          NAME                DRIVER              SCOPE
c5d098178e11        bridge              bridge              local
89abc367806c        docker_gwbridge     bridge              local
8d7d368667e5        host                host                local
dd0baa7e09a7        none                null                local
b6848140b7b8        ov_net1             overlay             global
[root@Docker2 ~]# #docker 会创建一个 bridge 网络 “docker_gwbridge”，为所有连接到 overlay 网络的容器提供访问外网的能力
[root@Docker2 ~]#
[root@Docker2 ~]# ifconfig  docker_gwbridge
docker_gwbridge: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.18.0.1  netmask 255.255.0.0  broadcast 0.0.0.0
        inet6 fe80::42:c9ff:fe89:d47f  prefixlen 64  scopeid 0x20<link>
        ether 02:42:c9:89:d4:7f  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

[root@Docker2 ~]#

```



+ 在192.168.1.243上能看到相同的overlay网络（ov_net1）

```shell
[root@Docker3 ~]# docker -H 127.0.0.1:2376 network ls
NETWORK ID          NAME                DRIVER              SCOPE
94c1be5dfe4a        bridge              bridge              local
762b41902533        host                host                local
fb7b29ac0f19        none                null                local
b6848140b7b8        ov_net1             overlay             global
[root@Docker3 ~]#
[root@Docker3 ~]# docker -H 127.0.0.1:2376 run -itd --name bbox2 --network ov_net1 busybox
Unable to find image 'busybox:latest' locally
Trying to pull repository docker.io/library/busybox ...
latest: Pulling from docker.io/library/busybox
009932687766: Pull complete
Digest: sha256:afcc7f1ac1b49db317a7196c902e61c6c3c4607d63599ee1a82d702d249a0ccb
Status: Downloaded newer image for docker.io/busybox:latest
dd70e2027e545866571179ea6597d224e6e604fcc1a3b3175688c2307da6175e
[root@Docker3 ~]#
[root@Docker3 ~]#
[root@Docker3 ~]# docker -H 127.0.0.1:2376 exec bbox2 ip r
default via 172.18.0.1 dev eth1
10.0.0.0/24 dev eth0 scope link  src 10.0.0.3
172.18.0.0/16 dev eth1 scope link  src 172.18.0.2
[root@Docker3 ~]#
[root@Docker3 ~]#
[root@Docker3 ~]# docker -H 127.0.0.1:2376 network ls
NETWORK ID          NAME                DRIVER              SCOPE
94c1be5dfe4a        bridge              bridge              local
56b893b6d5f5        docker_gwbridge     bridge              local
762b41902533        host                host                local
fb7b29ac0f19        none                null                local
b6848140b7b8        ov_net1             overlay             global
[root@Docker3 ~]#
[root@Docker3 ~]# ifconfig  docker_gwbridge
docker_gwbridge: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.18.0.1  netmask 255.255.0.0  broadcast 0.0.0.0
        inet6 fe80::42:c9ff:fe2d:b64f  prefixlen 64  scopeid 0x20<link>
        ether 02:42:c9:2d:b6:4f  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

[root@Docker3 ~]#
[root@Docker3 ~]# docker -H 127.0.0.1:2376 exec bbox2 ping -c 2 bbox1
PING bbox1 (10.0.0.2): 56 data bytes

--- bbox1 ping statistics ---
2 packets transmitted, 0 packets received, 100% packet loss
[root@Docker3 ~]# # 出错了，不能互通，网上说是内核版本低（3.10），不支持VxLan

```



### 5.2.3 Overlay的资源隔离

> docker -H 127.0.0.1:2376 network create -d overlay ov_net2
>
> docker -H 127.0.0.1:2376 run -itd --name bbox3 --network ov_net1 busybox
>
> docker -H 127.0.0.1:2376 exec bbox3 ping -c 2 bbox1 
>
> #上面一条命令的结果：ping不通
>
> docker -H 127.0.0.1:2376 network connect ov_net1 bbox3 
>
> docker -H 127.0.0.1:2376 exec bbox3 ping -c 2 bbox1 
>
> #上面一条命令的结果：ping通

## 5.3 flannel  网络

### 5.3.1 配置环境
+ 安装配置 etcd

```shell
## 安装 etcd
ETCD_VER=v2.3.7
DOWNLOAD_URL=https://github.com/coreos/etcd/releases/download
curl -L ${DOWNLOAD_URL}/${ETCD_VER}/etcd-${ETCD_VER}-linux-amd64.tar.gz -o /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz

mkdir -p /tmp/test-etcd && tar xzvf /tmp/etcd-${ETCD_VER}-linux-amd64.tar.gz -C /tmp/test-etcd --strip-components=1

cp /tmp/test-etcd/etcd* /usr/local/bin/

### 启动
[root@Docker1 ~]# etcd -listen-client-urls http://192.168.1.241:2379 -advertise-client-urls http://192.168.1.241:2379 --data-dir=/usr/local/etcd-data &disown


#测试 etcd 是否可用：
[root@Docker1 ~]# etcdctl --endpoints=192.168.1.241:2379 set foo "bar"
bar
[root@Docker1 ~]# etcdctl --endpoints=192.168.1.241:2379 get foo
bar
[root@Docker1 ~]# # 在防火墙中开端口
[root@Docker1 ~]# firewall-cmd --zone=public --add-port=2379/tcp --permanent
success
[root@Docker1 ~]# firewall-cmd --reload
success
[root@Docker1 ~]# 
```


+ 将 flannel 网络的配置信息保存到 etcd
```shell
[root@Docker1 ~]# echo '{

  "Network": "10.2.0.0/16",
  "SubnetLen": 24,
  "Backend": {
    "Type": "vxlan"
  }
}' > flannel-config.json
[root@Docker1 ~]# etcdctl --endpoints=192.168.1.241:2379 set /docker-test/network/config < flannel-config.json
{

  "Network": "10.2.0.0/16",
  "SubnetLen": 24,
  "Backend": {
    "Type": "vxlan"
  }
}

[root@Docker1 ~]# etcdctl --endpoints=192.168.1.241:2379 get /docker-test/network/config
{

  "Network": "10.2.0.0/16",
  "SubnetLen": 24,
  "Backend": {
    "Type": "vxlan"
  }
}

[root@Docker1 ~]#  
```

+ 安装flannel

  下载地址：https://objects.githubusercontent.com/github-production-release-asset-2e65be/21704134/3484e500-22f4-11e9-9843-373b7132bc2d?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20220223%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20220223T155908Z&X-Amz-Expires=300&X-Amz-Signature=220b679119f914d757d08b2a4c2fbf77554d608b58320f99cdaf7e9541f348c8&X-Amz-SignedHeaders=host&actor_id=0&key_id=0&repo_id=21704134&response-content-disposition=attachment%3B%20filename%3Dflannel-v0.11.0-linux-amd64.tar.gz&response-content-type=application%2Foctet-stream

  ```shell
  # 解压
  tar xzvf flannel-v0.11.0-linux-amd64.tar.gz
  # 复制到/usr/local/bin/
  cp flanneld /usr/local/bin/
  # 复制到别的机器上
  scp flanneld 1.1.1.1:/usr/local/bin/
  
  ```
+ 启动 flannel

```shell
[root@Docker1 ~]# flanneld -etcd-endpoints=http://192.168.1.241:2379 -iface=eth0 -etcd-prefix=/docker-test/network &disown 
#
# -etcd-endpoints 指定 etcd url。
# -iface 指定主机间数据传输使用的 interface。
# -etcd-prefix 指定 etcd 存放 flannel 网络配置信息的 key。
#
[root@Docker1 ~]# ip addr show   flannel.1
6: flannel.1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1450 qdisc noqueue state UNKNOWN
    link/ether de:bb:10:8c:63:da brd ff:ff:ff:ff:ff:ff
    inet 10.2.74.0/32 scope global flannel.1
       valid_lft forever preferred_lft forever
    inet6 fe80::dcbb:10ff:fe8c:63da/64 scope link
       valid_lft forever preferred_lft forever
[root@Docker1 ~]#
[root@Docker1 ~]# ip route
default via 192.168.1.1 dev eth0 proto static metric 100
10.2.54.0/24 via 10.2.54.0 dev flannel.1 onlink
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1
172.18.0.0/16 dev br-e7c6e0b50213 proto kernel scope link src 172.18.0.1
172.22.1.0/24 dev br-e3947fe7f93b proto kernel scope link src 172.22.1.1
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.241 metric 100
[root@Docker1 ~]#

```

+ 在host2上启动flannel

```shell
[root@Docker2 ~]# flanneld -etcd-endpoints=http://192.168.1.241:2379 -iface=eth0 -etcd-prefix=/docker-test/network &

[root@Docker2 ~]#
[root@Docker2 ~]# ip addr  show flannel.1
3: flannel.1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1450 qdisc noqueue state UNKNOWN
    link/ether 9a:ef:23:30:86:29 brd ff:ff:ff:ff:ff:ff
    inet 10.2.54.0/32 scope global flannel.1
       valid_lft forever preferred_lft forever
    inet6 fe80::98ef:23ff:fe30:8629/64 scope link
       valid_lft forever preferred_lft forever
[root@Docker2 ~]#
[root@Docker2 ~]# ip route
default via 192.168.1.1 dev eth0 proto static metric 100
10.2.74.0/24 via 10.2.74.0 dev flannel.1 onlink
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.242 metric 100
[root@Docker2 ~]#

```

+ 在host3上启动flannel

```shell
[root@Docker3 ~]# flanneld -etcd-endpoints=http://192.168.1.241:2379 -iface=eth0 -etcd-prefix=/docker-test/network &disown

[root@Docker3 ~]# ip addr show flannel.1
3: flannel.1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1450 qdisc noqueue state UNKNOWN
    link/ether 32:be:87:00:95:a1 brd ff:ff:ff:ff:ff:ff
    inet 10.2.16.0/32 scope global flannel.1
       valid_lft forever preferred_lft forever
    inet6 fe80::30be:87ff:fe00:95a1/64 scope link
       valid_lft forever preferred_lft forever
[root@Docker3 ~]# ip route
default via 192.168.1.1 dev eth0 proto static metric 100
10.2.54.0/24 via 10.2.54.0 dev flannel.1 onlink
10.2.74.0/24 via 10.2.74.0 dev flannel.1 onlink
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.243 metric 100
[root@Docker3 ~]#

```

### 5.3.2 在 Docker 中使用 flannel

+ host2配置 Docker 连接 flannel

```shell
[root@Docker2 ~]# cat /run/flannel/subnet.env
FLANNEL_NETWORK=10.2.0.0/16
FLANNEL_SUBNET=10.2.54.1/24
FLANNEL_MTU=1450
FLANNEL_IPMASQ=false
[root@Docker2 ~]# vim /usr/lib/systemd/system/docker.service
[root@Docker2 ~]# cat /usr/lib/systemd/system/docker.service
[Unit]
Description=Docker Application Container Engine
Documentation=http://docs.docker.com
After=network.target
Wants=docker-storage-setup.service
Requires=docker-cleanup.timer

[Service]
Type=notify
NotifyAccess=main
EnvironmentFile=-/run/containers/registries.conf
EnvironmentFile=-/etc/sysconfig/docker
EnvironmentFile=-/etc/sysconfig/docker-storage
EnvironmentFile=-/etc/sysconfig/docker-network
Environment=GOTRACEBACK=crash
Environment=DOCKER_HTTP_HOST_COMPAT=1
Environment=PATH=/usr/libexec/docker:/usr/bin:/usr/sbin
ExecStart=/usr/bin/dockerd-current \
          --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current \
          --default-runtime=docker-runc \
          --exec-opt native.cgroupdriver=systemd \
          --userland-proxy-path=/usr/libexec/docker/docker-proxy-current \
          --init-path=/usr/libexec/docker/docker-init-current \
          --seccomp-profile=/etc/docker/seccomp.json \
          -H tcp://0.0.0.0:2376 \
          --bip=10.2.54.1/24 \
          --mtu=1450 \
          $OPTIONS \
          $DOCKER_STORAGE_OPTIONS \
          $DOCKER_NETWORK_OPTIONS \
          $ADD_REGISTRY \
          $BLOCK_REGISTRY \
          $INSECURE_REGISTRY \
          $REGISTRIES
ExecReload=/bin/kill -s HUP $MAINPID
LimitNOFILE=1048576
LimitNPROC=1048576
LimitCORE=infinity
TimeoutStartSec=0
Restart=on-abnormal
KillMode=process

[Install]
WantedBy=multi-user.target
[root@Docker2 ~]#
[root@Docker2 ~]# systemctl daemon-reload
[root@Docker2 ~]# systemctl restart docker.service
[root@Docker2 ~]# ip r
default via 192.168.1.1 dev eth0 proto static metric 100
10.2.16.0/24 via 10.2.16.0 dev flannel.1 onlink
10.2.54.0/24 dev docker0 proto kernel scope link src 10.2.54.1
10.2.74.0/24 via 10.2.74.0 dev flannel.1 onlink
172.18.0.0/16 dev docker_gwbridge proto kernel scope link src 172.18.0.1
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.242 metric 100
[root@Docker2 ~]#

```

--bip , --mtu 必须与 /run/flannel/subnet.env 中 `FLANNEL_SUBNET` 和`FLANNEL_MTU` 一致。

+ host3配置 Docker 连接 flannel

```shell
[root@Docker3 ~]# cat /run/flannel/subnet.env
FLANNEL_NETWORK=10.2.0.0/16
FLANNEL_SUBNET=10.2.16.1/24
FLANNEL_MTU=1450
FLANNEL_IPMASQ=false
[root@Docker3 ~]# vim /usr/lib/systemd/system/docker.service
[root@Docker3 ~]# cat /usr/lib/systemd/system/docker.service
[Unit]
Description=Docker Application Container Engine
Documentation=http://docs.docker.com
After=network.target
Wants=docker-storage-setup.service
Requires=docker-cleanup.timer

[Service]
Type=notify
NotifyAccess=main
EnvironmentFile=-/run/containers/registries.conf
EnvironmentFile=-/etc/sysconfig/docker
EnvironmentFile=-/etc/sysconfig/docker-storage
EnvironmentFile=-/etc/sysconfig/docker-network
Environment=GOTRACEBACK=crash
Environment=DOCKER_HTTP_HOST_COMPAT=1
Environment=PATH=/usr/libexec/docker:/usr/bin:/usr/sbin
ExecStart=/usr/bin/dockerd-current \
          --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current \
          --default-runtime=docker-runc \
          --exec-opt native.cgroupdriver=systemd \
          --userland-proxy-path=/usr/libexec/docker/docker-proxy-current \
          --init-path=/usr/libexec/docker/docker-init-current \
          --seccomp-profile=/etc/docker/seccomp.json \
          -H tcp://0.0.0.0:2376 \
          --bip=10.2.16.1/24 \
          --mtu=1450 \
          $OPTIONS \
          $DOCKER_STORAGE_OPTIONS \
          $DOCKER_NETWORK_OPTIONS \
          $ADD_REGISTRY \
          $BLOCK_REGISTRY \
          $INSECURE_REGISTRY \
          $REGISTRIES
ExecReload=/bin/kill -s HUP $MAINPID
LimitNOFILE=1048576
LimitNPROC=1048576
LimitCORE=infinity
TimeoutStartSec=0
Restart=on-abnormal
KillMode=process

[Install]
WantedBy=multi-user.target
[root@Docker3 ~]#
[root@Docker3 ~]# systemctl daemon-reload
[root@Docker3 ~]# systemctl restart docker.service
[root@Docker3 ~]# ip r
default via 192.168.1.1 dev eth0 proto static metric 100
10.2.16.0/24 dev docker0 proto kernel scope link src 10.2.16.1
10.2.54.0/24 via 10.2.54.0 dev flannel.1 onlink
10.2.74.0/24 via 10.2.74.0 dev flannel.1 onlink
172.18.0.0/16 dev docker_gwbridge proto kernel scope link src 172.18.0.1
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.243 metric 100
[root@Docker3 ~]#
```

+ 容器连接到 flannel 网络

host2:
```shell
[root@Docker2 ~]# docker -H 127.0.0.1:2376 run -itd --name bbox1 busybox
2b32242d7ebd1a2cbabe031358afee33ecc834b1b9294d1cbf6f601334481e1c
[root@Docker2 ~]# docker -H 127.0.0.1:2376 exec bbox1 ip r
default via 10.2.54.1 dev eth0
10.2.54.0/24 dev eth0 scope link  src 10.2.54.2
[root@Docker2 ~]#

```
host3:
```shell
[root@Docker3 ~]# docker -H 127.0.0.1:2376 run -itd --name bbox2 busybox
e5beb62b4ff8a562fee379cf32a8b044d84a23bfdfc4b653aba5292bdd3af865
[root@Docker3 ~]# docker -H 127.0.0.1:2376 exec bbox2 ip r
default via 10.2.16.1 dev eth0
10.2.16.0/24 dev eth0 scope link  src 10.2.16.2
[root@Docker3 ~]#

```

### 5.3.3 flannel 的连通与隔离

+ flannel 网络连通性









# 附录

## 附录1：docker命令检索

### 附录1.1 与镜像相关

images   显示镜像列表

history  显示镜像构建历史

commit   从容器创建新镜像

build   从 Dockerfile 构建镜像

tag    给镜像打 tag

pull    从 registry 下载镜像

push    将 镜像 上传到 registry

rmi    删除 Docker host 中的镜像

search   搜索 Docker Hub 中的镜像

### 附录1.2 与容器相关

rm 删除非运行状态的容器    ; 删除非运行容器：docker rm -v $(docker ps -aq -f status=exited) 

inspect 查看容器配置





## 附录2： 本地镜像的导出、导入

1. 在外网机器上查看，并使用`docker save`导出镜像

```shell
[root@localhost ~]# docker images
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
REPOSITORY                 TAG         IMAGE ID      CREATED        SIZE
docker.io/library/ubuntu   latest      d13c942271d6  11 days ago    75.2 MB
localhost/fhbx             latest      0057dba583c6  13 days ago    328 MB
localhost/worden525/fhbx   latest      0057dba583c6  13 days ago    328 MB
quay.io/centos/centos      7           8652b9f0cb4c  14 months ago  212 MB
docker.io/progrium/stress  latest      db646a8f4087  7 years ago    291 MB
[root@localhost ~]# docker save 0057dba583c6 >fhbx_docker_image.tar
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
[root@localhost ~]#
```

2. 在内网机器上使用`docker load`导入镜像

```shell
[root@localhost ~]# docker load < fhbx_docker_image.tar
fae28ac4b88a: Loading layer [==================================================>] 115.9 MB/115.9 MB
Loaded image ID: sha256:0057dba583c6b21ecc2cbc027abbbf7820a9870ef161a2d08c6ab0d822d906e5
[root@localhost ~]# docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
docker.io/ubuntu             latest              d13c942271d6        11 days ago         72.8 MB
<none>                       <none>              0057dba583c6        13 days ago         319 MB
docker.io/busybox            latest              beae173ccac6        2 weeks ago         1.24 MB
docker.io/gitlab/gitlab-ee   latest              935605e8a1c8        4 weeks ago         2.54 GB
docker.io/httpd              latest              dabbfbe0c57b        4 weeks ago         144 MB
worden525/httpd              1.0                 dabbfbe0c57b        4 weeks ago         144 MB
docker.io/registry           2                   b8604a3fe854        2 months ago        26.2 MB
docker.io/centos             7                   eeb6ee3f44bd        4 months ago        204 MB
[root@localhost ~]#
[root@localhost ~]# docker tag 0057dba583c6 fhbx
[root@localhost ~]# docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
docker.io/ubuntu             latest              d13c942271d6        11 days ago         72.8 MB
fhbx                         latest              0057dba583c6        13 days ago         319 MB
docker.io/busybox            latest              beae173ccac6        2 weeks ago         1.24 MB
docker.io/gitlab/gitlab-ee   latest              935605e8a1c8        4 weeks ago         2.54 GB
docker.io/httpd              latest              dabbfbe0c57b        4 weeks ago         144 MB
worden525/httpd              1.0                 dabbfbe0c57b        4 weeks ago         144 MB
docker.io/registry           2                   b8604a3fe854        2 months ago        26.2 MB
docker.io/centos             7                   eeb6ee3f44bd        4 months ago        204 MB
[root@localhost ~]#
[root@localhost ~]# docker history 0057dba583c6
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
0057dba583c6        13 days ago         /bin/sh -c #(nop) CMD /home/jexus/jwss          0 B
<missing>           13 days ago         /bin/sh -c #(nop) ADD file:e1d740327aa8f52...   115 MB              FROM quay.io/centos/centos:7
<missing>           14 months ago       /bin/sh -c #(nop)  CMD ["/bin/bash"]            0 B
<missing>           14 months ago       /bin/sh -c #(nop)  LABEL org.label-schema....   0 B
<missing>           14 months ago       /bin/sh -c #(nop) ADD file:b3ebbe8bd304723...   204 MB
[root@localhost ~]#
[root@localhost ~]# docker run -d -p 8086:8085 fhbx
6bd27b6791bcb205e34c6f120270396705a494e37e39a4425837a0d5234fc26a
[root@localhost ~]# curl http://127.0.0.1:8086/
```

## 附录3 利用docker-compose启动容器

### 附录3.1 docker-compose.yml（示例）

```shell
[root@Docker1 gitlab]# pwd
/home/gitlab
[root@Docker1 gitlab]# ls
config  data  docker-compose.yml  logs
[root@Docker1 gitlab]#
[root@Docker1 gitlab]# cat docker-compose.yml
version: '2.0'
services:
  gitlab:
    image: gitlab/gitlab-ee:latest
    hostname: 192.166.1.241
    # restart: always
    container_name: gitlab2
    ports:
      - "8053:443"
      - "8052:80"
      - "60022:22"
    volumes:
      - /home/gitlab/config:/etc/gitlab
      - /home/gitlab/logs:/var/log/gitlab
      - /home/gitlab/data:/var/opt/gitlab
    shm_size: 256m

[root@Docker1 gitlab]#
```

### 附录3.2 启动容器

> 在docker-compose.yml的目录下执行 `docker-compose up -d`，以

```shell
[root@Docker1 home]# cd fhbx/
[root@Docker1 fhbx]# ls
[root@Docker1 fhbx]# cat docker-compose.yml
version: '2.0'
services:
  gitlab:
    image: worden525/fhbx:1.0
    hostname: 192.166.1.241
    # restart: always
    container_name: fhbx
    ports:
      - "8085:8085"
[root@Docker1 fhbx]#
[root@Docker1 fhbx]#
[root@Docker1 fhbx]# docker-compose up -d
[+] Running 2/2
 ⠿ Network fhbx_default  Created                       1.1s
 ⠿ Container fhbx        Started                       1.9s
[root@Docker1 fhbx]# docker ps
CONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS              PORTS                              NAMES
e7dc461401a7        worden525/fhbx:1.0   "/bin/sh -c /home/..."   7 seconds ago       Up 5 seconds        0.0.0.0:8085->8085/tcp             fhbx
[root@Docker1 fhbx]#

```

### 附录3.3 停止容器

>  在docker-compose.yml的目录下执行 `docker-compose down`

```shell
[root@Docker1 fhbx]# ls
docker-compose.yml
[root@Docker1 fhbx]#
[root@Docker1 fhbx]# docker-compose down
[+] Running 2/2
 ⠿ Container fhbx        Removed                            10.4s
 ⠿ Network fhbx_default  Removed                            0.6s
[root@Docker1 fhbx]#
[root@Docker1 fhbx]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@Docker1 fhbx]#
```

## 附录4 升级docker-ce并且保留镜像

参见：https://cdn.modb.pro/db/111819



## 附录5 多阶段构建镜像

1. 使用序号，<font color=red>需要在docker-ce下使用，go 编译的时候需要使用 --tags netgo  ，否则程序不能启动</font>

```dockerfile
# build step
FROM worden525/centos7-golang
COPY simpleHttpServer.go /
RUN cd / && go build --tags netgo simpleHttpServer.go
CMD [ "/simpleHttpServer" ]

# create real app image
FROM alpine
COPY --from=0  /simpleHttpServer /
CMD [ "/simpleHttpServer" ]
```

2. as做别名

```dockerfile
# build step
FROM worden525/centos7-golang as bimg
COPY simpleHttpServer.go /
RUN cd / && go build --tags netgo simpleHttpServer.go
CMD [ "/simpleHttpServer" ]

# create real app image
FROM alpine
COPY --from=bimg  /simpleHttpServer /
CMD [ "/simpleHttpServer" ]

```


## 附录6 从镜像中查看Dockerfile
```shell
docker history --format {{.CreatedBy}} --no-trunc=true tag:version |sed "s?/bin/sh\ -c\ \#(nop)\ ??g"|sed "s?/bin/sh\ -c?RUN?g" | tac

#比如：
docker history --format {{.CreatedBy}} --no-trunc=true topsec/shiro-721:latest|sed "s?/bin/sh\ -c\ \#(nop)\ ??g"|sed "s?/bin/sh\ -c?RUN?g" | tac
#写入Dockerfile
docker history --format {{.CreatedBy}} --no-trunc=true topsec/shiro-721:latest|sed "s?/bin/sh\ -c\ \#(nop)\ ??g"|sed "s?/bin/sh\ -c?RUN?g" | tac > Dockerfile
```




## 附录98 防火墙开端口

firewall-cmd --zone=public --add-port=2376/tcp --permanent

firewall-cmd --reload

## 附录99 容器生态

``` mermaid
graph LR
A[容器生态系统]-->B[容器核心技术]
A[容器生态系统]-->C[容器平台技术]
A[容器生态系统]-->D[容器支持技术]
B-->B01[容器规范]
B-->B02[容器 runtime]
B-->B03[容器管理工具]
B-->B04[容器定义工具]
B-->B05[Registries]
B-->B06[容器 OS]
B01-->|OCI| B0101[runtime spec]
B01-->|OCI| B0102[image format spec]
B02-->|Linux| B0201[lxc]
B02-->|Docker| B0202[runc]
B02-->|CoreOS| B0203[rkt]
B03-->|lxc| B0301[lxd]
B03-->|runc| B0302[docker engine]
B03-->|rkt| B0303[rkt cli]
B04-->|Docker| B0401[docker image]
B04-->|Docker| B0402[dockerfile]
B04-->|CoreOS| B0403[ACI<br/>App Container Image]
B05-->|私有| B0501[Docker Registry]
B05-->|公共| B0502[Docker Hub <br/>https://hub.docker.com]
B05-->|公共| B0503[Quay.io <br/>https://quay.io]
B06-->B0601[CoreOS]
B06-->B0602[atomic]
B06-->B0603[ubuntu core]
C-->C01[容器编排引擎]
C-->C02[容器管理平台]
C-->C03[基于容器的PaaS]
C01-->|Docker|C0101[docker swarm]
C01-->|Google 领导|C0102[kubernetes]
C01-->C0103[mesos+marathon ]
C02-->C0201[Rancher]
C02-->C0202[ContainerShip]
C03-->C0301[Deis]
C03-->C0302[Flynn]
C03-->C0303[Dokku]
D-->D01[容器网络]
D-->D02[服务发现]
D-->D03[监管]
D-->D04[数据管理]
D-->D05[日志管理]
D-->D06[安全性]
D01-->D0101[docker network]
D01-->D0102[flannel]
D01-->D0103[weave]
D01-->D0104[calico]
D02-->D0201[etcd]
D02-->D0202[consul]
D02-->D0203[zookeeper]
D03-->|Docker原生命令|D0301[docker ps/top/stats]
D03-->|HTTP接口|D0302[docker stats API]
D03-->D0303[sysdig]
D03-->D0304[cAdvisor/Heapster]
D03-->D0305[Weave Scope]
D04-->|动态迁移|D0401[Flocker]
D05-->|Docker 原生|D0501[docker logs]
D05-->|提供路由功能|D0502[logspout]
D06-->|对镜像扫描|D0601[OpenSCAP]
```

# 注脚

[^Sandbox说明]: Sandbox 是容器的网络栈，包含容器的 interface、路由表和 DNS 设置。 Linux Network Namespace 是 Sandbox 的标准实现。Sandbox 可以包含来自不同 Network 的 Endpoint。

[^Endpoint说明]: Endpoint 的作用是将 Sandbox 接入 Network。Endpoint 的典型实现是 veth pair，后面我们会举例。一个 Endpoint 只能属于一个网络，也只能属于一个 Sandbox。

[^Network说明]: Network 包含一组 Endpoint，同一 Network 的 Endpoint 可以直接通信。Network 的实现可以是 Linux Bridge、VLAN 等。


